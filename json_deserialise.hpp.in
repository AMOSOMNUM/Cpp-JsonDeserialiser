#ifndef HPP_JSON_DESERIALISER_
#define HPP_JSON_DESERIALISER_

#include <functional>
#include <ios>
#include <optional>
#include <variant>

#include "json_deserialise.@JSON_DESERIALISE_DEFAULT_JSON_LIBRARY_SUFFIX@.h"
#include "utilities.hpp"

inline namespace JsonDeserialise {
enum class Trait : unsigned {
    NUL = 0,
    OBJECT = 1,
    ARRAY = 2,
    FIELD = 4,
    OPTIONAL = 8,
};

enum class ArrayInsertWay : unsigned {
    Unknown = 0,
    Emplace_Back = 1,
    Push_Back = 2,
    Append = 4,
    Insert = 8,
};

template <typename T, typename Element>
struct GetArrayInsertWay {
    static constexpr ArrayInsertWay calculate() {
        ArrayInsertWay result = ArrayInsertWay::Unknown;

        if (is_emplaceback<T, Element>(nullptr))
            result = ArrayInsertWay(unsigned(result) | unsigned(ArrayInsertWay::Emplace_Back));
        if (is_pushback<T, Element>(nullptr))
            result = ArrayInsertWay(unsigned(result) | unsigned(ArrayInsertWay::Push_Back));
        if (is_append<T, Element>(nullptr))
            result = ArrayInsertWay(unsigned(result) | unsigned(ArrayInsertWay::Append));
        if (is_insert<T, Element>(nullptr))
            result = ArrayInsertWay(unsigned(result) | unsigned(ArrayInsertWay::Insert));

        return result;
    }
    template <typename U, typename V, typename = decltype(std::declval<U>().emplace_back())>
    static constexpr bool is_emplaceback(int* p) {
        return true;
    }
    template <typename...>
    static constexpr bool is_emplaceback(...) {
        return false;
    }
    template <typename U, typename V,
              typename = decltype(std::declval<U>().push_back(std::declval<V>()))>
    static constexpr bool is_pushback(int* p) {
        return true;
    }
    template <typename...>
    static constexpr bool is_pushback(...) {
        return false;
    }
    template <typename U, typename V,
              typename = decltype(std::declval<U>().append(std::declval<V>()))>
    static constexpr bool is_append(int* p) {
        return true;
    }
    template <typename...>
    static constexpr bool is_append(...) {
        return false;
    }
    template <typename U, typename V,
              typename = decltype(std::declval<U>().insert(std::declval<V>()))>
    static constexpr bool is_insert(int* p) {
        return true;
    }
    template <typename...>
    static constexpr bool is_insert(...) {
        return false;
    }
    static constexpr ArrayInsertWay value = calculate();
    static constexpr bool insert_only = value == ArrayInsertWay::Insert;

    inline static Element& push_back(T& container) {
        if constexpr (unsigned(value) & unsigned(ArrayInsertWay::Emplace_Back))
            return container.emplace_back();
        else {
            if constexpr (unsigned(value) & unsigned(ArrayInsertWay::Push_Back))
                container.push_back(Element());
            else if constexpr (unsigned(value) & unsigned(ArrayInsertWay::Append))
                container.append(Element());
            return container.back();
        }
    }
};

template <typename Lib = @JSON_DESERIALISE_DEFAULT_JSON_LIBRARY@Adaptation>
struct Deserialiser {
    template <typename Any>
    using DeserialisableType = typename Lib::template DeserialisableType<Any>;

    template <typename T, const char* json_name, auto member_offset>
    using Customised = typename Lib::template Customised<T, json_name, member_offset>;

    using StringConstRef = const typename Lib::String&;
    using StringConst = const typename Lib::String;
    using Json = typename Lib::Json;

    template <typename T>
    using StringConvertor = typename Lib::template StringConvertor<T>;

    template <typename T, typename Nullable>
    struct NullableHandler;
    template <typename T>
    struct NullableHandler<T, std::optional<T>> {
        inline static decltype(auto) convert(const T& value) {
            return value;
        }
        constexpr inline static decltype(auto) make_empty() {
            return std::nullopt;
        }
    };
    template <typename T>
    struct NullableHandler<T, T*> {
        inline static T* convert(const T& value) {
            return new T(value);
        }
        constexpr inline static T* make_empty() {
            return nullptr;
        }
    };
    template <>
    struct NullableHandler<const char*, const char*> {
        inline static const char* convert(const char* value) {
            return value;
        }
        constexpr inline static const char* make_empty() {
            return nullptr;
        }
    };
    template <>
    struct NullableHandler<char*, char*> {
        inline static char* convert(char* value) {
            return value;
        }
        constexpr inline static char* make_empty() {
            return nullptr;
        }
    };

    class DeserialisableBase {
    public:
        void* const data_ptr;
        union INFO {
            const Trait flag;
            const void* const const_ptr;

            INFO(Trait flag) : flag(flag) {}
            INFO(const void* ptr) : const_ptr(ptr) {}
        } info;
        StringConst identifier;

    protected:
        DeserialisableBase(void* ptr, Trait _as = Trait::NUL) : data_ptr(ptr), info(_as) {}
        DeserialisableBase(void* ptr, StringConstRef name, bool optional = false)
            : data_ptr(ptr), info(optional ? Trait::OPTIONAL : Trait::FIELD), identifier(name) {}
        DeserialisableBase(const void* ptr) : data_ptr(nullptr), info(ptr) {}
        DeserialisableBase(const void* ptr, StringConstRef name)
            : data_ptr(nullptr), info(ptr), identifier(name) {}
        DeserialisableBase(const DeserialisableBase&) = delete;
        DeserialisableBase& operator=(const DeserialisableBase&) = delete;

        template <typename T>
        inline T& value() noexcept {
            return *reinterpret_cast<T*>(data_ptr);
        }

        template <typename T>
        inline const T& value() const noexcept {
            return *reinterpret_cast<const T*>(data_ptr ? data_ptr : info.const_ptr);
        }
    };

    template <typename T = void, typename... Args>
    inline static constexpr bool isValid() {
        return std::is_same_v<T, void> ||
               std::is_base_of_v<DeserialisableBase, T> && isValid<Args...>();
    }

    template <typename T>
    inline static void deserialise_each(const typename Lib::JsonObject& object,
                                        DeserialisableBase&& each) {
#ifdef _DEBUG
        if (!unsigned(each.info.flag))
            throw std::ios_base::failure("JSON Structure Declaration Invalid!");
#endif
        bool contain = Lib::exists(object, each.identifier);
        if (!(contain || (unsigned(each.info.flag) & unsigned(Trait::OPTIONAL))))
            throw std::ios_base::failure("JSON Structure Incompatible!");
        if (contain)
            static_cast<T&>(each).assign(object[each.identifier]);
    }

    template <typename T>
    inline static void insert_each(typename Lib::JsonObject& object,
                                   const DeserialisableBase& each) {
        object.insert(each.identifier, static_cast<const T&>(each).to_json());
    }

    template <typename T>
    inline static void append_each(typename Lib::JsonArray& array, const DeserialisableBase& each) {
        Lib::append(array, static_cast<const T&>(each).to_json());
    }

    template <typename... Args>
    struct JsonDeserialiser {
        static constexpr int N = sizeof...(Args);
        const std::enable_if_t<N && isValid<Args...>(), DeserialisableBase*> data[N];

        JsonDeserialiser(Args&... args) : data{&args...} {}

        inline void deserialise_file(StringConstRef filepath) {
            deserialise(Lib::parse_file(filepath));
        }
        inline void deserialise(typename Lib::StringView json) {
            deserialise(Lib::parse(json));
        }
        inline void serialise_to_file(StringConstRef filepath, bool compress = false) const {
            Lib::write_json(serialise_to_json(), filepath, compress);
        }
        inline typename Lib::CString serialise(bool compress = false) const {
            Lib::print_json(serialise_to_json(), compress);
        }

        void deserialise(const Json& json) {
            if constexpr (N == 1)
                ((typename PackToType<Args...>::Type*)data[0])->assign(json);
            else {
                int count = 0;
                (deserialise_each<Args>(json, *data[count++]), ...);
            }
        }

        inline void deserialise(const typename Lib::JsonObject& object) {
            deserialise(static_cast<const Json&>(object));
        }

        inline std::enable_if_t<N == 1> deserialise(const typename Lib::JsonArray& array) {
            deserialise(static_cast<const Json&>(array));
        }

        Json serialise_to_json() const {
            if constexpr (N == 1)
                return ((typename PackToType<Args...>::Type*)data[0])->to_json();
            else {
                typename Lib::JsonObject obj;
                int count = 0;
                ((insert_each<Args>(obj, *data[count++])), ...);
                return obj;
            }
        }
    };

    struct Boolean : public DeserialisableBase {
        using Target = bool;

        Boolean(bool& source) : DeserialisableBase(&source) {}
        Boolean(StringConstRef name, bool& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Boolean(const bool& source) : DeserialisableBase(&source) {}
        Boolean(StringConstRef name, const bool& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (Lib::is_bool(json))
                this->template value<Target>() = Lib::get_bool(json);
            else if (Lib::is_string(json)) {
                auto str = Lib::get_string(json).toLower();
                if (str == "true")
                    this->template value<Target>() = true;
                else if (str == "false")
                    this->template value<Target>() = false;
                else if (str == "1")
                    this->template value<Target>() = true;
                else if (str == "0")
                    this->template value<Target>() = false;
                else if (str.isEmpty())
                    this->template value<Target>() = false;
                else
                    throw std::ios_base::failure("Type Unmatch!");
            } else if (Lib::is_null(json))
                this->template value<Target>() = false;
            else if (Lib::is_number(json)) {
                int val = Lib::get_int(json);
                if (val & -2)
                    throw std::ios_base::failure("Type Unmatch!");
                this->template value<Target>() = val;
            } else
                throw std::ios_base::failure("Type Unmatch!");
        }
        Json to_json() const {
            return this->template value<Target>();
        }
    };

    template <bool sign, size_t size>
    struct Integer;

    template <>
    struct Integer<true, sizeof(int)> : public DeserialisableBase {
        using Target = int;

        Integer(int& source) : DeserialisableBase(&source) {}
        Integer(StringConstRef name, int& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Integer(const int& source) : DeserialisableBase(&source) {}
        Integer(StringConstRef name, const int& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (Lib::is_number(json))
                this->template value<Target>() = Lib::get_int(json);
            else if (Lib::is_string(json))
                this->template value<Target>() = Lib::str2int(Lib::get_string(json));
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        Json to_json() const {
            return this->template value<Target>();
        }
    };

    template <>
    struct Integer<false, sizeof(unsigned)> : public DeserialisableBase {
        using Target = unsigned;

        Integer(unsigned& source) : DeserialisableBase(&source) {}
        Integer(StringConstRef name, unsigned& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Integer(const unsigned& source) : DeserialisableBase(&source) {}
        Integer(StringConstRef name, const unsigned& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (Lib::is_number(json))
                this->template value<Target>() = Lib::get_uint(json);
            else if (Lib::is_string(json))
                this->template value<Target>() = Lib::str2uint(Lib::get_string(json));
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        Json to_json() const {
            return Lib::uint2json(this->template value<Target>());
        }
    };

    template <typename T>
    struct Real;

    template <>
    struct Real<double> : public DeserialisableBase {
        using Target = double;

        Real(double& source) : DeserialisableBase(&source) {}
        Real(StringConstRef name, double& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Real(const double& source) : DeserialisableBase(&source) {}
        Real(StringConstRef name, const double& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (Lib::is_number(json))
                this->template value<Target>() = Lib::get_double(json);
            else if (Lib::is_string(json))
                this->template value<Target>() = Lib::str2double(Lib::get_string(json));
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        Json to_json() const {
            return this->template value<Target>();
        }
    };

    template <typename T>
    struct String : public DeserialisableBase {
        using Target = T;

        String(Target& source) : DeserialisableBase(&source) {}
        String(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        String(const Target& source) : DeserialisableBase(&source) {}
        String(StringConstRef name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (!Lib::is_string(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            this->template value<Target>() =
                StringConvertor<Target>::convert(Lib::get_string(json));
        }
        Json to_json() const {
            return StringConvertor<Target>::deconvert(this->template value<Target>());
        }
    };

    template <size_t length>
    struct String<char[length]> : public DeserialisableBase {
        using Target = char[length];

        inline char* value() const noexcept {
            return reinterpret_cast<char*>(DeserialisableBase::data_ptr);
        }
        inline const char* const_value() const noexcept {
            return reinterpret_cast<const char*>(DeserialisableBase::data_ptr
                                                     ? DeserialisableBase::data_ptr
                                                     : DeserialisableBase::info.const_ptr);
        }

        String(char* source) : DeserialisableBase(source) {}
        String(StringConstRef name, char* source, bool optional = false)
            : DeserialisableBase(source, name, optional) {}
        String(const char* source) : DeserialisableBase(source) {}
        String(StringConstRef name, const char* source) : DeserialisableBase(source, name) {}

        inline void assign(const Json& json) {
            if (!Lib::is_string(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            Lib::template char_array_write<length>(value(), Lib::get_string(json));
        }
        Json to_json() const {
            return StringConvertor<const char*>::deconvert(const_value());
        }
    };

    template <typename T, typename StringType>
    struct NullableString : public DeserialisableBase {
        using Target = T;

        NullableString(Target& source) : DeserialisableBase(&source) {}
        NullableString(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        NullableString(const Target& source) : DeserialisableBase(&source) {}
        NullableString(StringConstRef name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (!Lib::is_string(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            if (!Lib::is_null(json))
                this->template value<Target>() = NullableHandler<StringType, T>::convert(
                    StringConvertor<StringType>::convert(Lib::get_string(json)));
        }
        Json to_json() const {
            if constexpr (std::is_same_v<std::remove_cv_t<std::remove_pointer_t<StringType>>, char>)
                return this->template value<Target>() ? this->template value<Target>() : Json();
            else
                return this->template value<Target>()
                           ? StringConvertor<StringType>::deconvert(*this->template value<Target>())
                           : Json();
        }
    };

    template <typename T, typename StringType>
    struct StringArray : public DeserialisableBase {
        using Target = T;

        StringArray(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        StringArray(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        StringArray(const Target& source) : DeserialisableBase(&source) {}
        StringArray(StringConstRef name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            static_assert(bool(GetArrayInsertWay<T, StringType>::value));
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : Lib::get_array(json)) {
                if (!Lib::is_string(i) && !Lib::is_null(i))
                    throw std::ios_base::failure("Type Unmatch!");
                if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                              unsigned(ArrayInsertWay::Push_Back))
                    this->template value<Target>().push_back(
                        StringConvertor<StringType>::convert(Lib::get_string(i)));
                else if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                   unsigned(ArrayInsertWay::Append))
                    this->template value<Target>().append(
                        StringConvertor<StringType>::convert(Lib::get_string(i)));
                else if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                   unsigned(ArrayInsertWay::Insert))
                    this->template value<Target>().insert(
                        StringConvertor<StringType>::convert(Lib::get_string(i)));
            }
        }
        Json to_json() const {
            typename Lib::JsonArray array;
            for (const auto& i : this->template value<Target>())
                Lib::append(array, StringConvertor<StringType>::deconvert(i));
            return array;
        }
    };

    template <typename T, typename NullableStringType, typename StringType>
    struct NullableStringArray : public DeserialisableBase {
        using Target = T;

        NullableStringArray(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        NullableStringArray(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        NullableStringArray(const Target& source) : DeserialisableBase(&source) {}
        NullableStringArray(StringConstRef name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : Lib::get_array(json))
                if (Lib::is_string(i)) {
                    if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                  unsigned(ArrayInsertWay::Push_Back))
                        this->template value<Target>().push_back(
                            NullableHandler<NullableStringType, StringType>::convert(
                                StringConvertor<StringType>::convert(Lib::get_string(i))));
                    else if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                       unsigned(ArrayInsertWay::Append))
                        this->template value<Target>().append(
                            NullableHandler<NullableStringType, StringType>::convert(
                                StringConvertor<StringType>::convert(Lib::get_string(i))));
                    else if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                       unsigned(ArrayInsertWay::Insert))
                        this->template value<Target>().insert(
                            NullableHandler<NullableStringType, StringType>::convert(
                                StringConvertor<StringType>::convert(Lib::get_string(i))));
                } else if (Lib::is_null(i)) {
                    if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                  unsigned(ArrayInsertWay::Push_Back))
                        this->template value<Target>().push_back(
                            NullableHandler<NullableStringType, StringType>::make_empty());
                    else if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                       unsigned(ArrayInsertWay::Append))
                        this->template value<Target>().append(
                            NullableHandler<NullableStringType, StringType>::make_empty());
                    else if constexpr (unsigned(GetArrayInsertWay<T, StringType>::value) &
                                       unsigned(ArrayInsertWay::Insert))
                        this->template value<Target>().insert(
                            NullableHandler<NullableStringType, StringType>::make_empty());
                } else
                    throw std::ios_base::failure("Type Unmatch!");
        }
        Json to_json() const {
            typename Lib::JsonArray array;
            for (const auto& i : this->template value<Target>())
                if constexpr (std::is_same_v<std::remove_cv_t<std::remove_pointer_t<StringType>>,
                                             char>)
                    Lib::append(array, i ? i : Json());
                else
                    Lib::append(array, i ? StringConvertor<StringType>::deconvert(*i) : Json());
            return array;
        }
    };

    template <typename T, typename StringType, std::size_t N>
    struct LimitedStringArray : public StringArray<T, StringType> {
        using Base = StringArray<T, StringType>;
        using Target = T;

        LimitedStringArray(Target& source) : Base(source) {}
        LimitedStringArray(StringConstRef name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        LimitedStringArray(const Target& source) : Base(source) {}
        LimitedStringArray(StringConstRef name, const Target& source) : Base(name, source) {}

        void assign(const Json& json) {
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            int count = 0;
            for (const auto& i : Lib::get_array(json)) {
                if (!Lib::is_string(i) && !Lib::is_null(i))
                    throw std::ios_base::failure("Type Unmatch!");
                if (count == N)
                    throw std::ios_base::failure("Array Out of Range!");
                this->template value<Target>()[count++] =
                    StringConvertor<StringType>::convert(Lib::get_string(i));
            }
        }
    };

    template <typename T, typename NullableStringType, typename StringType, std::size_t N>
    struct LimitedNullableStringArray
        : public NullableStringArray<T, NullableStringType, StringType> {
        using Base = NullableStringArray<T, NullableStringType, StringType>;
        using Target = T;

        LimitedNullableStringArray(Target& source) : Base(source) {}
        LimitedNullableStringArray(StringConstRef name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        LimitedNullableStringArray(const Target& source) : Base(source) {}
        LimitedNullableStringArray(StringConstRef name, const Target& source)
            : Base(name, source) {}

        void assign(const Json& json) {
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            int count = 0;
            for (const auto& i : Lib::get_array(json)) {
                if (count == N)
                    throw std::ios_base::failure("Array Out of Range!");
                if (!Lib::is_null(i))
                    this->template value<Target>()[count++] =
                        NullableHandler<NullableStringType, StringType>::convert(
                            StringConvertor<StringType>::convert(Lib::get_string(i)));
                else
                    this->template value<Target>()[count++] =
                        NullableHandler<NullableStringType, StringType>::make_empty();
            }
        }
    };

    template <typename T, auto member_offset>
    struct ObjectArrayInfo : public Lib::String {
        using Prototype = DeserialisableType<decltype(((T*)nullptr)->member_offset)>;
    };

    template <typename T, auto... Members>
    struct ObjectArray : public DeserialisableBase {
        using Target = T;
        using ObjectType = typename Lib::template Deserialisable<Target>::TypeInArray;
        StringConst identifiers[sizeof...(Members)];

        ObjectArray(T& source, ObjectArrayInfo<ObjectType, Members>&&... members)
            : DeserialisableBase(&source, Trait::ARRAY), identifiers{std::move(members)...} {}
        ObjectArray(StringConstRef name, T& source,
                    ObjectArrayInfo<ObjectType, Members>&&... members)
            : DeserialisableBase(&source, name), identifiers{std::move(members)...} {}
        ObjectArray(const T& source, ObjectArrayInfo<ObjectType, Members>&&... members)
            : DeserialisableBase(&source), identifiers{std::move(members)...} {}
        ObjectArray(StringConstRef name, const T& source,
                    ObjectArrayInfo<ObjectType, Members>&&... members)
            : DeserialisableBase(&source, name), identifiers{std::move(members)...} {}

        void assign(const Json& json) {
            static_assert(bool(GetArrayInsertWay<T, ObjectType>::value));
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : Lib::get_array(json)) {
                if (!Lib::is_object(i))
                    throw std::ios_base::failure("Type Unmatch!");
                StringConst* ptr = identifiers;
                if constexpr (!GetArrayInsertWay<T, ObjectType>::insert_only) {
                    ObjectType& obj =
                        GetArrayInsertWay<T, ObjectType>::push_back(this->template value<Target>());
                    (deserialise_each<typename ObjectArrayInfo<ObjectType, Members>::Prototype>(
                         Lib::get_object(i),
                         typename ObjectArrayInfo<ObjectType, Members>::Prototype(*ptr++,
                                                                                  obj.*Members)),
                     ...);
                } else {
                    ObjectType obj;
                    (deserialise_each<typename ObjectArrayInfo<ObjectType, Members>::Prototype>(
                         Lib::get_object(i),
                         typename ObjectArrayInfo<ObjectType, Members>::Prototype(*ptr++,
                                                                                  obj.*Members)),
                     ...);
                    this->template value<Target>().insert(std::move(obj));
                }
            }
        }
        Json to_json() const {
            typename Lib::JsonArray array;
            for (const auto& i : this->template value<Target>()) {
                StringConst* ptr = identifiers;
                (append_each<typename ObjectArrayInfo<ObjectType, Members>::Prototype>(
                     array,
                     typename ObjectArrayInfo<ObjectType, Members>::Prototype(*ptr++, i.*Members)),
                 ...);
            }
            return array;
        }
    };

    template <typename T, typename TypeInArray>
    struct Array : public DeserialisableBase {
        using Target = T;
        using Prototype = DeserialisableType<TypeInArray>;

        Array(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        Array(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Array(const Target& source) : DeserialisableBase(&source) {}
        Array(StringConstRef name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            static_assert(bool(GetArrayInsertWay<T, TypeInArray>::value));
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : Lib::get_array(json)) {
                if constexpr (!GetArrayInsertWay<T, TypeInArray>::insert_only) {
                    Prototype deserialiser(GetArrayInsertWay<T, TypeInArray>::push_back(
                        this->template value<Target>()));
                    deserialiser.assign(i);
                } else {
                    TypeInArray tmp;
                    Prototype deserialiser(tmp);
                    deserialiser.assign(i);
                    this->template value<Target>().insert(std::move(tmp));
                }
            }
        }
        Json to_json() const {
            typename Lib::JsonArray array;
            for (const auto& i : this->template value<Target>()) {
                Prototype serialiser(i);
                Lib::append(array, serialiser.to_json());
            }
            return array;
        }
    };

    template <typename T, typename TypeInArray, std::size_t N>
    struct LimitedArray : public Array<T, TypeInArray> {
        using Base = Array<T, TypeInArray>;
        using Target = T;
        using Prototype = DeserialisableType<TypeInArray>;

        LimitedArray(Target& source) : Base(source) {}
        LimitedArray(StringConstRef name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        LimitedArray(const Target& source) : Base(source) {}
        LimitedArray(StringConstRef name, const Target& source) : Base(name, source) {}

        void assign(const Json& json) {
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            if constexpr (bool(GetArrayInsertWay<T, TypeInArray>::value))
                for (const auto& i : Lib::get_array(json)) {
                    if (this->template value<Target>().size() == N)
                        throw std::ios_base::failure("Array Out of Range!");
                    if constexpr (!GetArrayInsertWay<T, TypeInArray>::insert_only) {
                        Prototype deserialiser(GetArrayInsertWay<T, TypeInArray>::push_back(
                            this->template value<Target>()));
                        deserialiser.assign(i);
                    } else {
                        TypeInArray tmp;
                        Prototype deserialiser(tmp);
                        deserialiser.assign(i);
                        this->template value<Target>().insert(std::move(tmp));
                    }
                }
            else {
                int count = 0;
                for (const auto& i : Lib::get_array(json)) {
                    if (count == N)
                        throw std::ios_base::failure("Array Out of Range!");
                    Prototype deserialiser(this->template value<Target>()[count++]);
                    deserialiser.assign(i);
                }
            }
        }
    };

    template <typename T, typename TypeInNullable>
    struct Nullable : public DeserialisableBase {
        using Target = T;

        Nullable(Target& source) : DeserialisableBase(&source) {}
        Nullable(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Nullable(const Target& source) : DeserialisableBase(&source) {}
        Nullable(StringConstRef name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (Lib::is_null(json)) {
                this->template value<Target>() =
                    NullableHandler<TypeInNullable, Target>::make_empty();
                return;
            }
            TypeInNullable tmp;
            DeserialisableType<TypeInNullable> deserialiser(tmp);
            deserialiser.assign(json);
            this->template value<Target>() = NullableHandler<TypeInNullable, Target>::convert(tmp);
        }
        Json to_json() const {
            return this->template value<Target>()
                       ? DeserialisableType<TypeInNullable>(*this->template value<Target>())
                             .to_json()
                       : Json();
        }
    };

    template <typename T, typename As>
    struct AsTrivial : public DeserialisableType<As> {
        using Base = DeserialisableType<As>;
        using Target = T;

        AsTrivial(Target& source) : Base(reinterpret_cast<As&>(source)) {}
        AsTrivial(StringConstRef name, Target& source, bool optional = false)
            : Base(name, reinterpret_cast<As&>(source), optional) {}
        AsTrivial(const Target& source) : Base(reinterpret_cast<const As&>(source)) {}
        AsTrivial(StringConstRef name, const Target& source)
            : Base(name, reinterpret_cast<const As&>(source)) {}
    };

    template <typename T, const char* json_name, size_t json_name_length, auto member_offset,
              bool optional_member = false,
              typename Custom = typename Customised<T, json_name, member_offset>::Type>
    struct ReinforcedInfo {
        using Type = T;
        using Prototype = Custom;
        static constexpr const char* name = json_name;
        static constexpr size_t name_length = json_name_length;
        static constexpr auto member_ptr = member_offset;
        static constexpr bool optional = optional_member;
    };

    template <typename ObjectType, typename... MemberInfo>
    struct Object : public DeserialisableBase {
        using Target = ObjectType;

        Object(Target& source) : DeserialisableBase(&source, Trait::OBJECT) {}
        Object(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Object(const Target& source) : DeserialisableBase(&source) {}
        Object(StringConstRef name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (!Lib::is_object(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            (deserialise_each<typename MemberInfo::Prototype>(
                 Lib::get_object(json),
                 typename MemberInfo::Prototype(MemberInfo::name, this->template value<Target>().*
                                                                      MemberInfo::member_ptr)),
             ...);
        }
        Json to_json() const {
            typename Lib::JsonObject obj;
            (insert_each<const typename MemberInfo::Prototype>(
                 obj,
                 typename MemberInfo::Prototype(MemberInfo::name, this->template value<Target>().*
                                                                      MemberInfo::member_ptr)),
             ...);
            return obj;
        }
    };

    template <class BaseType, class Derived, typename... MemberInfo>
    struct DerivedObject : public DeserialisableType<BaseType> {
        using Base = DeserialisableType<BaseType>;
        using Target = Derived;

        DerivedObject(Target& source) : Base(source) {}
        DerivedObject(StringConstRef name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        DerivedObject(const Target& source) : Base(source) {}
        DerivedObject(StringConstRef name, const Target& source) : Base(name, source) {}

        void assign(const Json& json) {
            if (!Lib::is_object(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            Base::assign(json);
            (deserialise_each<typename MemberInfo::Prototype>(
                 Lib::get_object(json),
                 typename MemberInfo::Prototype(MemberInfo::name, this->template value<Target>().*
                                                                      MemberInfo::member_ptr)),
             ...);
        }

        Json to_json() const {
            auto obj = Lib::get_object(Base::to_json());
            (insert_each<const typename MemberInfo::Prototype>(
                 obj,
                 typename MemberInfo::Prototype(MemberInfo::name, this->template value<Target>().*
                                                                      MemberInfo::member_ptr)),
             ...);
            return obj;
        }
    };

    template <typename ObjectType>
    struct SelfDeserialisableObject : public DeserialisableBase {
        using Target = ObjectType;

        SelfDeserialisableObject(Target& source) : DeserialisableBase(&source, Trait::OBJECT) {}
        SelfDeserialisableObject(StringConstRef name, ObjectType& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        SelfDeserialisableObject(const Target& source) : DeserialisableBase(&source) {}
        SelfDeserialisableObject(StringConstRef name, const ObjectType& source)
            : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (!Lib::is_object(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            this->template value<Target>() = std::move(Target(Lib::get_object(json)));
        }
        Json to_json() const {
            return this->template value<Target>().to_json();
        }
    };

    template <typename T, typename KeyType, typename ValueType>
    struct ObjectMap : public DeserialisableBase {
        using Target = T;
        StringConst key;

        ObjectMap(Target& source, StringConstRef key_name)
            : DeserialisableBase(&source, Trait::ARRAY), key(key_name) {}
        ObjectMap(StringConstRef name, Target& source, StringConstRef key_name)
            : DeserialisableBase(&source, name), key(key_name) {}
        ObjectMap(const Target& source, StringConstRef key_name)
            : DeserialisableBase(&source), key(key_name) {}
        ObjectMap(StringConstRef name, const Target& source, StringConstRef key_name)
            : DeserialisableBase(&source, name), key(key_name) {}

        void assign(const Json& json) {
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : Lib::get_array(json)) {
                const auto& obj = Lib::get_object(i);
                if (!Lib::exists(obj, key))
                    throw std::ios_base::failure("Type Unmatch!");
                KeyType key_field;
                DeserialisableType<KeyType> key_deserialiser(key_field);
                key_deserialiser.assign(obj[key]);
                ValueType value_obj;
                DeserialisableType<ValueType> value_deserialiser(value_obj);
                value_deserialiser.assign(obj);
                this->template value<Target>()[key_field] = std::move(value_obj);
            }
        }
        Json to_json() const {
            typename Lib::JsonArray array;
            for (const auto& [key_, value_] : this->template value<Target>()) {
                DeserialisableType<ValueType> value_deserialiser(value_);
                auto obj = Lib::get_object(value_deserialiser.to_json());
                DeserialisableType<KeyType> key_deserialiser(key_);
                obj.insert(key, key_deserialiser.to_json());
                Lib::append(array, std::move(obj));
            }
            return array;
        }
    };

    template <typename T, typename KeyType, typename ValueType>
    struct Map : public DeserialisableBase {
        using Target = T;

        Map(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        Map(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Map(const Target& source) : DeserialisableBase(&source) {}
        Map(StringConstRef name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const Json& json) {
            if (!Lib::is_array(json) && !Lib::is_null(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& [_key, _value] : Lib::get_object(json)) {
                KeyType key;
                ValueType value_;
                DeserialisableType<KeyType> key_deserialiser(key);
                DeserialisableType<ValueType> value_deserialiser(value_);
                key_deserialiser.assign(_key);
                value_deserialiser.assign(_value);
                this->template value<Target>()[key] = std::move(value_);
            }
        }
        Json to_json() const {
            typename Lib::JsonObject obj;
            for (const auto& [key, value] : this->template value<Target>()) {
                DeserialisableType<KeyType> key_deserialiser(key);
                DeserialisableType<ValueType> value_deserialiser(value);
                obj.insert(key_deserialiser.to_json(), value_deserialiser.to_json());
            }
            return obj;
        }
    };

    template <typename T, typename Type1, typename Type2>
    struct Pair : public DeserialisableBase {
        using Target = T;
        StringConst name[2];

        Pair(Target& source, StringConstRef name1, StringConstRef name2)
            : DeserialisableBase(&source, Trait::OBJECT), name{name1, name2} {}
        Pair(StringConstRef json_name, Target& source, StringConstRef name1, StringConstRef name2)
            : DeserialisableBase(&source, json_name), name{name1, name2} {}
        Pair(const Target& source, StringConstRef name1, StringConstRef name2)
            : DeserialisableBase(&source), name{name1, name2} {}
        Pair(StringConstRef json_name, const Target& source, StringConstRef name1,
             StringConstRef name2)
            : DeserialisableBase(&source, json_name), name{name1, name2} {}

        void assign(const Json& json) {
            if (!Lib::is_object(json))
                throw std::ios_base::failure("Type Unmatch!");
            Type1& element1 = this->template value<Target>().first;
            Type2& element2 = this->template value<Target>().second;
            DeserialisableType<Type1> deserialiser1(element1);
            DeserialisableType<Type2> deserialiser2(element2);
            deserialiser1.assign(Lib::get_object(json)[name[0]]);
            deserialiser2.assign(Lib::get_object(json)[name[1]]);
        }
        Json to_json() const {
            typename Lib::JsonObject pair;
            const DeserialisableType<Type1> serialiser1(this->template value<Target>().first);
            const DeserialisableType<Type2> serialiser2(this->template value<Target>().second);
            pair.insert(name[0], serialiser1.to_json());
            pair.insert(name[1], serialiser2.to_json());
            return pair;
        }
    };

    template <typename Des, typename ConvertFunctor,
              typename BasicType = std::decay_t<typename ArgTypeDeduction<decltype(std::function(
                  std::declval<ConvertFunctor>()))>::Type>>
    struct DeserialiseOnlyConvertor : decltype(std::function(std::declval<ConvertFunctor>())) {
        using Type = BasicType;
        using Target = std::decay_t<Des>;
        using Source = std::decay_t<BasicType>;
        using FunctionType = decltype(std::function(std::declval<ConvertFunctor>()));

        template <typename T>
        DeserialiseOnlyConvertor(T&& convertor) : FunctionType(convertor) {}
    };

    template <typename Convertor>
    class DeserialiseOnlyExtension : public DeserialisableBase {
    public:
        using Type = DeserialisableType<typename Convertor::Type>;
        using Target = typename Convertor::Target;
        using Source = typename Convertor::Source;

    protected:
        std::decay_t<Convertor> convertor;

    public:
        template <typename T>
        DeserialiseOnlyExtension(T&& convertor, Target& source)
            : DeserialisableBase(&source), convertor(std::forward<T>(convertor)) {}
        template <typename T>
        DeserialiseOnlyExtension(T&& convertor, StringConstRef name, Target& source,
                                 bool optional = false)
            : DeserialisableBase(&source, name, optional), convertor(std::forward<T>(convertor)) {}

        void assign(const Json& json) {
            Source tmp;
            Type(tmp).assign(json);
            this->template value<Target>() = convertor(tmp);
        }
    };
    template <typename Des, typename ConvertFunctor>
    DeserialiseOnlyExtension(ConvertFunctor&&, Des&)
        -> DeserialiseOnlyExtension<DeserialiseOnlyConvertor<Des, ConvertFunctor>>;
    template <typename Des, typename ConvertFunctor>
    DeserialiseOnlyExtension(ConvertFunctor&&, StringConstRef, Des&, bool)
        -> DeserialiseOnlyExtension<DeserialiseOnlyConvertor<Des, ConvertFunctor>>;

    template <typename Des, typename ConvertFunctor,
              typename BasicType =
                  std::decay_t<decltype(std::declval<ConvertFunctor>()(std::declval<Des>()))>>
    struct SerialiseOnlyConvertor : decltype(std::function(std::declval<ConvertFunctor>())) {
        using Type = BasicType;
        using Target = std::decay_t<Des>;
        using Source = std::decay_t<BasicType>;
        using FunctionType = decltype(std::function(std::declval<ConvertFunctor>()));

        template <typename T>
        SerialiseOnlyConvertor(T&& convertor) : FunctionType(convertor) {}
    };

    template <typename Convertor>
    class SerialiseOnlyExtension : public DeserialisableBase {
    public:
        using Type = DeserialisableType<typename Convertor::Type>;
        using Target = typename Convertor::Target;
        using Source = typename Convertor::Source;

    protected:
        std::decay_t<Convertor> convertor;

    public:
        template <typename T>
        SerialiseOnlyExtension(T&& convertor, const Target& source)
            : DeserialisableBase(&source), convertor(std::forward<T>(convertor)) {}
        template <typename T>
        SerialiseOnlyExtension(T&& convertor, StringConstRef name, const Target& source)
            : DeserialisableBase(&source, name), convertor(std::forward<T>(convertor)) {}

        Json to_json() const {
            auto tmp = convertor(this->template value<Target>());
            return Type(tmp).to_json();
        }
    };
    template <typename Des, typename ConvertFunctor>
    SerialiseOnlyExtension(ConvertFunctor&&, const Des&)
        -> SerialiseOnlyExtension<SerialiseOnlyConvertor<Des, ConvertFunctor>>;
    template <typename Des, typename ConvertFunctor>
    SerialiseOnlyExtension(ConvertFunctor&&, StringConstRef, const Des&, bool)
        -> SerialiseOnlyExtension<SerialiseOnlyConvertor<Des, ConvertFunctor>>;

    template <typename Des, typename ConvertFunctor = Des(const Json&),
              typename DeconvertFunctor = Json(const Des&),
              typename BasicType = decltype(std::declval<DeconvertFunctor>()(std::declval<Des>()))>
    struct Convertor {
        using Type = BasicType;
        using Target = std::decay_t<Des>;
        using Source = std::decay_t<BasicType>;
        DeserialiseOnlyConvertor<Des, ConvertFunctor, BasicType> convertor;
        SerialiseOnlyConvertor<Des, DeconvertFunctor, BasicType> deconvertor;

        template <typename U, typename V>
        Convertor(U&& convertor, V&& deconvertor)
            : convertor(std::forward<U>(convertor)), deconvertor(std::forward<V>(deconvertor)) {}
        explicit Convertor()
            : convertor{[](const Json& json) {
                  using T = DeserialisableType<Des>;
                  Des result;
                  T(result).assign(json);
                  return result;
              }},
              deconvertor{[](const Des& src) {
                  using T = DeserialisableType<Des>;
                  return T(src).to_json();
              }} {}
    };

    template <typename Convertor>
    class Extension : public DeserialisableBase {
    public:
        using Type = DeserialisableType<typename Convertor::Type>;
        using Target = typename Convertor::Target;
        using Source = typename Convertor::Source;

    protected:
        std::decay_t<Convertor> convertor;

    public:
        template <typename U, typename V>
        Extension(U&& convertor, V&& deconvertor, Target& source)
            : DeserialisableBase(&source),
              convertor(std::forward<U>(convertor), std::forward<V>(deconvertor)) {}
        template <typename U, typename V>
        Extension(U&& convertor, V&& deconvertor, StringConstRef name, Target& source,
                  bool optional = false)
            : DeserialisableBase(&source, name, optional),
              convertor(std::forward<U>(convertor), std::forward<V>(deconvertor)) {}

        void assign(const Json& json) {
            Source tmp;
            Type(tmp).assign(json);
            this->template value<Target>() = convertor.convertor(tmp);
        }
        Json to_json() const {
            auto tmp = convertor.deconvertor(this->template value<Target>());
            return Type(tmp).to_json();
        }
    };

    template <typename Des, typename ConvertFunctor, typename DeconvertFunctor>
    Extension(ConvertFunctor&&, DeconvertFunctor&&, Des&)
        -> Extension<Convertor<Des, ConvertFunctor, DeconvertFunctor>>;
    template <typename Des, typename ConvertFunctor, typename DeconvertFunctor>
    Extension(ConvertFunctor&&, DeconvertFunctor&&, StringConstRef, Des&, bool)
        -> Extension<Convertor<Des, ConvertFunctor, DeconvertFunctor>>;

    template <typename Standard, typename Tuple, int current = 0,
              typename Result = typename ConstexprConstantArray<Standard::length, -1>::Type,
              bool = Tuple::length <= 1>
    struct ConvertorAdapterReorganise;

    template <typename... Targets, int current, typename Last, typename Current, typename... Left>
    struct ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<Current, Left...>, current,
                                      Last, false> {
        static constexpr int index =
            FindType<TypeTuple<Targets...>, typename Current::Target>::index;
        using Next = ConvertorAdapterReorganise<
            TypeTuple<Targets...>, TypeTuple<Left...>, current + 1,
            typename ConstexprArrayPackAlter<index, current, Last>::Type>;
        using Type = typename Next::Type;
    };

    template <typename... Targets, int current, typename Last, typename Current>
    struct ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<Current>, current, Last,
                                      true> {
        static constexpr int index =
            FindType<TypeTuple<Targets...>, typename Current::Target>::index;
        using Type = typename ConstexprArrayPackAlter<index, current, Last>::Type;
    };

    template <typename... Targets, typename Result>
    struct ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<void>, 0, Result, true> {
        using Type = Result;
    };

    template <int N, typename Target, typename Given>
    inline Convertor<Target> ConvertorGenerator(Given& given) {
        if constexpr (N == -1)
            return std::move(Convertor<Target>());
        else
            return std::move(given.template get<N>());
    };

    template <typename Target, typename Inc, typename... Given>
    struct ConvertorAdapter;

    template <typename... Targets, int... pack, typename... Given>
    struct ConvertorAdapter<std::variant<Targets...>, ConstexprArrayPack<pack...>, Given...> {
        using Array =
            typename ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<Given...>>::Type;
        using Tuple = TypeTuple<Given...>;
        using Target = TypeTuple<Targets...>;
        StaticTuple<Convertor<Given>...> givens;
        StaticTuple<Convertor<Targets>...> convertors;

        ConvertorAdapter(Given&... given)
            : givens(given...),
              convertors(
                  ConvertorGenerator<Array::value[pack], typename GetType<pack, Target>::Type>(
                      givens)...) {}
    };

    template <typename Variant>
    struct GetNum;

    template <typename... Types>
    struct GetNum<std::variant<Types...>> {
        constexpr static int value = sizeof...(Types);
    };

    template <typename Target,
              typename Inc = typename ConstexprIncArray<GetNum<Target>::value>::Type>
    class VarientObject;

    template <typename... Targets, typename Deductor, typename... Given_Convertors>
    VarientObject(std::variant<Targets...>&, StringConstRef, Deductor&&, Given_Convertors&&...)
        -> VarientObject<std::variant<Targets...>>;
    template <typename... Targets, typename Deductor, typename... Given_Convertors>
    VarientObject(StringConstRef, std::variant<Targets...>&, StringConstRef, Deductor&&,
                  Given_Convertors&&...) -> VarientObject<std::variant<Targets...>>;

    template <typename... Targets, int... pack>
    class VarientObject<std::variant<Targets...>, ConstexprArrayPack<pack...>>
        : public DeserialisableBase {
    protected:
        using Target = std::variant<Targets...>;
        StringConst identifier;
        std::function<int(const Json&)> deductor;
        StaticTuple<Convertor<Targets>...> convertors;

    public:
        template <typename Deductor, typename... Given_Convertors>
        VarientObject(Target& source, StringConstRef identifier, Deductor&& deduction,
                      Given_Convertors&&... convertors)
            : DeserialisableBase(&source, Trait::OBJECT), identifier(identifier),
              deductor(std::forward<Deductor>(deduction)),
              convertors(ConvertorAdapter<Target, ConstexprArrayPack<pack...>, Given_Convertors...>(
                             convertors...)
                             .convertors) {}
        template <typename Deductor, typename... Given_Convertors>
        VarientObject(StringConstRef name, Target& source, StringConstRef identifier,
                      Deductor&& deduction, Given_Convertors&&... convertors)
            : DeserialisableBase(&source, name), identifier(identifier),
              deductor(std::forward<Deductor>(deduction)),
              convertors(ConvertorAdapter<Target, ConstexprArrayPack<pack...>, Given_Convertors...>(
                             convertors...)
                             .convertors) {}

        template <int N>
        void assign_if_eq(int index, const typename Lib::JsonObject& obj) {
            if (N == index)
                this->template value<Target>().emplace<N>(convertors.get<N>().convertor(obj));
        }
        template <int N>
        void serialise_if_eq(int index, Json& json) {
            if (N == index)
                json = convertors.get<N>().deconvertor(json);
        }

        void assign(const Json& json) {
            if (!Lib::is_object(json) || !Lib::exists(Lib::get_object(json), identifier))
                throw std::ios_base::failure("Type Unmatch!");
            const auto& obj = Lib::get_object(json);
            int index = deductor(obj[identifier]);
            if (index == -1)
                throw std::ios_base::failure("Type Unmatch!");
            (assign_if_eq<pack>(index, obj), ...);
        }
        Json to_json() const {
            Json result;
            int index = this->template value<Target>().index();
            (serialise_if_eq<pack>(index, result), ...);
        }
    };

    template <typename T, typename Prototype = DeserialisableType<T>>
    class EndoExtension : public Prototype {
        std::function<void(T&)> functor;

    public:
        template <typename Functor>
        EndoExtension(Functor&& f, T& source) : Prototype(source), functor(f) {}
        template <typename Functor>
        EndoExtension(Functor&& f, StringConstRef json_name, T& source, bool optional = false)
            : Prototype(json_name, source, optional), functor(f) {}

        void assign(const Json& json) {
            Prototype::assign(json);
            functor(Prototype::value);
        }
    };

    class JSONWrap : public DeserialisableBase {
        using Target = Json;

    public:
        JSONWrap(Target& source) : DeserialisableBase(&source) {}
        JSONWrap(StringConstRef name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        JSONWrap(const Target& source) : DeserialisableBase(&source) {}
        JSONWrap(StringConstRef name, const Target& source) : DeserialisableBase(&source, name) {}

        inline void assign(const Json& json) {
            this->template value<Target>() = json;
        }
        inline Json to_json() const {
            return this->template value<Target>();
        }
    };

    template <typename Container, typename T>
    struct ArrayTypeInfo {
        using ArrayType = Container;
        using TypeInArray = T;
    };

    template <typename Container, typename Key, typename Value>
    struct MapTypeInfo {
        using MapType = Container;
        using KeyType = Key;
        using ValueType = Value;
        using _OBJECT_MAP_ = ObjectMap<Container, KeyType, ValueType>;
    };
};

} // namespace JsonDeserialise

#endif // HPP_JSON_DESERIALISER_

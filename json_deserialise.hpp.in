#include <functional>
#include <list>
#include <map>
#include <optional>
#include <set>
#include <variant>
#include <vector>

#include "utilities.hpp"

namespace JsonDeserialise {
namespace @LIB_ID@ {
    template <typename T>
    struct is_string {
        static constexpr bool value = StringConvertor<T>::value;
    };

    template <typename T, typename Nullable>
    struct NullableHandler;
    template <typename T>
    struct NullableHandler<T, std::optional<T>> {
        inline static decltype(auto) convert(const T& value) {
            return value;
        }
        constexpr inline static decltype(auto) make_empty() {
            return std::nullopt;
        }
    };
    template <typename T>
    struct NullableHandler<T, T*> {
        inline static T* convert(const T& value) {
            return new T(value);
        }
        constexpr inline static T* make_empty() {
            return nullptr;
        }
    };
    template <>
    struct NullableHandler<const char*, const char*> {
        inline static const char* convert(const char* value) {
            return value;
        }
        constexpr inline static const char* make_empty() {
            return nullptr;
        }
    };
    template <>
    struct NullableHandler<char*, char*> {
        inline static char* convert(char* value) {
            return value;
        }
        constexpr inline static char* make_empty() {
            return nullptr;
        }
    };
    template <typename T>
    struct is_nullable {
        using Type = void;
        static constexpr bool value = false;
    };

    template <typename T>
    struct is_nullable<T*> {
        using Type = T;
        static constexpr bool value = true;
    };
    template <>
    struct is_nullable<const char*> {
        using Type = const char*;
        static constexpr bool value = true;
    };
    template <>
    struct is_nullable<char*> {
        using Type = char*;
        static constexpr bool value = true;
    };

    template <typename T>
    struct is_nullable<std::optional<T>> {
        using Type = T;
        static constexpr bool value = true;
    };

    // Primary Template
    template <typename Any, bool isArray = false, int size = -1, typename TypeInArray = void,
              int isNullable = -1, typename TypeInNullable = void, int isString = -1>
    struct _Deserialisable;

    template <typename Any, bool isArray = false, int size = -1, typename TypeInArray = void,
              int isNullable = -1, typename TypeInNullable = void, int isString = -1>
    using _DeserialisableType =
        typename _Deserialisable<std::decay_t<Any>, isArray, size, TypeInArray, isNullable,
                                 TypeInNullable, isString>::Type;

    template <typename Any>
    struct Deserialisable {
        using Type = _DeserialisableType<std::decay_t<Any>>;
    };

    template <typename Any>
    using DeserialisableType = typename Deserialisable<Any>::Type;

    class DeserialisableBase {
    public:
        void* const data_ptr;
        const union INFO {
            Trait flag;
            const void* const_ptr;

            INFO(Trait flag) : flag(flag) {}
            INFO(const void* ptr) : const_ptr(ptr) {}
        } info;
        const STRING_TYPE identifier;

    protected:
        DeserialisableBase(void* ptr, Trait _as = Trait::NUL) : data_ptr(ptr), info(_as) {}
        DeserialisableBase(void* ptr, const STRING_TYPE& name, bool optional = false)
            : data_ptr(ptr), info(optional ? Trait::OPTIONAL : Trait::FIELD), identifier(name) {}
        DeserialisableBase(const void* ptr) : data_ptr(nullptr), info(ptr) {}
        DeserialisableBase(const void* ptr, const STRING_TYPE& name)
            : data_ptr(nullptr), info(ptr), identifier(name) {}
        DeserialisableBase(const DeserialisableBase&) = delete;
        DeserialisableBase& operator=(const DeserialisableBase&) = delete;

        template <typename T>
        inline T& value() {
            return *reinterpret_cast<T*>(data_ptr);
        }

        template <typename T>
        inline const T& value() const {
            return *reinterpret_cast<const T*>(data_ptr ? data_ptr : info.const_ptr);
        }
    };

    template <typename T = void, typename... Args>
    constexpr bool isValid() {
        return std::is_same_v<T, void> ||
               std::is_base_of_v<DeserialisableBase, T> && isValid<Args...>();
    }

    template <typename T>
    inline static void deserialise_each(const JSON_OBJECT_TYPE& object, DeserialisableBase&& each) {
        if (!size_t(each.info.flag))
            throw std::ios_base::failure("JSON Structure Declaration Invalid!");
        bool contain = @LIB_ID@_OBJECT_CONTAINS_KEY(object, each.identifier);
        if (!(contain || (size_t(each.info.flag) & size_t(Trait::OPTIONAL))))
            throw std::ios_base::failure("JSON Structure Incompatible!");
        if (contain)
            static_cast<T&>(each).assign(object[each.identifier]);
    }

    template <typename T>
    inline static void insert_each(JSON_OBJECT_TYPE& object, const DeserialisableBase& each) {
        object.insert(each.identifier, static_cast<const T&>(each).to_json());
    }

    template <typename T>
    inline static void append_each(JSON_ARRAY_TYPE& array, const DeserialisableBase& each) {
        @LIB_ID@_ARRAY_APPEND(array, static_cast<const T&>(each).to_json());
    }

    template <typename... Args>
    class JsonDeserialiser {
        static constexpr int N = sizeof...(Args);
        const std::enable_if_t<N && isValid<Args...>(), DeserialisableBase*> data[N];

    public:
#ifdef NDEBUG
        JsonDeserialiser(Args&... args) : data{&args...} {}
#else
        const Trait root_trait;
        JsonDeserialiser(Args&... args) : data{&args...}, root_trait(data[0]->info.flag) {}
#endif
        // Implementation Needed
        void deserialiseFile(const STRING_TYPE& filepath);
        void deserialise(const char* json);
        void deserialise(const STRING_TYPE& json);
        void deserialise(const BYTE_ARRAY_TYPE& json);
        void serialise_to_file(const STRING_TYPE& filepath, bool compress = false) const;

    public:
        void deserialise(const JSON_OBJECT_TYPE& object) {
#ifndef NDEBUG
            if (!size_t(root_trait))
                throw std::ios_base::failure("JSON Structure Declaration Invalid!");
            if (size_t(root_trait) & size_t(Trait::ARRAY))
                throw std::ios_base::failure("JSON Structure Incompatible!");
#endif
            if constexpr (N == 1)
                ((typename PackToType<Args...>::Type*)data[0])->assign(object);
            else {
                int count = 0;
                (deserialise_each<Args>(object, *data[count++]), ...);
            }
        }
        void deserialise(const JSON_ARRAY_TYPE& array) {
            if constexpr (N == 1)
                ((typename PackToType<Args...>::Type*)data[0])->assign(array);
#ifndef NDEBUG
            throw std::ios_base::failure("JSON Structure Incompatible!");
#endif
        }
        BYTE_ARRAY_TYPE serialise(bool compress = false) const;
        JSON_TYPE serialise_to_json() const {
            if constexpr (N == 1)
                return ((typename PackToType<Args...>::Type*)data[0])->to_json();
            else {
                JSON_OBJECT_TYPE obj;
                int count = 0;
                ((insert_each<Args>(obj, *data[count++])), ...);
                return obj;
            }
        }
    };

    struct Boolean : public DeserialisableBase {
        using Target = bool;

        Boolean(bool& source) : DeserialisableBase(&source) {}
        Boolean(const STRING_TYPE& name, bool& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Boolean(const bool& source) : DeserialisableBase(&source) {}
        Boolean(const STRING_TYPE& name, const bool& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (@LIB_ID@_IS_STRING(json)) {
                auto str = @LIB_ID@_GET_STRING(json).toLower();
                if (str == @LIB_ID@_STRING_LITERAL_WRAP("true"))
                    value<Target>() = true;
                else if (str == @LIB_ID@_STRING_LITERAL_WRAP("false"))
                    value<Target>() = false;
                else if (str.isEmpty())
                    value<Target>() = false;
                throw std::ios_base::failure("Type Unmatch!");
            } else if (@LIB_ID@_IS_NULL(json))
                value<Target>() = false;
            else if (@LIB_ID@_IS_BOOL(json))
                value<Target>() = @LIB_ID@_GET_BOOL(json);
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        JSON_TYPE to_json() const {
            return value<Target>();
        }
    };

    template <bool sign, size_t size>
    struct Integer;

    template <>
    struct Integer<true, sizeof(int)> : public DeserialisableBase {
        using Target = int;

        Integer(int& source) : DeserialisableBase(&source) {}
        Integer(const STRING_TYPE& name, int& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Integer(const int& source) : DeserialisableBase(&source) {}
        Integer(const STRING_TYPE& name, const int& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (@LIB_ID@_IS_STRING(json))
                value<Target>() = @LIB_ID@_STRING_TO_INT_THROW(@LIB_ID@_GET_STRING(json));
            else if (@LIB_ID@_IS_NUMBER(json))
                value<Target>() = @LIB_ID@_GET_INT(json);
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        JSON_TYPE to_json() const {
            return value<Target>();
        }
    };

    template <>
    struct Integer<false, sizeof(unsigned)> : public DeserialisableBase {
        using Target = unsigned;

        Integer(unsigned& source) : DeserialisableBase(&source) {}
        Integer(const STRING_TYPE& name, unsigned& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Integer(const unsigned& source) : DeserialisableBase(&source) {}
        Integer(const STRING_TYPE& name, const unsigned& source)
            : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (@LIB_ID@_IS_NUMBER(json))
                value<Target>() = @LIB_ID@_GET_INT(json);
            else if (@LIB_ID@_IS_STRING(json))
                value<Target>() = @LIB_ID@_STRING_TO_UINT_THROW(@LIB_ID@_GET_STRING(json));
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        JSON_TYPE to_json() const {
            return @LIB_ID@_UINT_WRAP(value<Target>());
        }
    };

    template <typename T>
    struct Real;

    template <>
    struct Real<double> : public DeserialisableBase {
        using Target = double;

        Real(double& source) : DeserialisableBase(&source) {}
        Real(const STRING_TYPE& name, double& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Real(const double& source) : DeserialisableBase(&source) {}
        Real(const STRING_TYPE& name, const double& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (@LIB_ID@_IS_NUMBER(json))
                value<Target>() = @LIB_ID@_GET_DOUBLE(json);
            else if (@LIB_ID@_IS_STRING(json))
                value<Target>() = @LIB_ID@_STRING_TO_DOUBLE_THROW(@LIB_ID@_GET_STRING(json));
            else
                throw std::ios_base::failure("Type Unmatch!");
        }
        JSON_TYPE to_json() const {
            return value<Target>();
        }
    };

    template <typename T>
    struct String : public DeserialisableBase {
        using Target = T;

        String(Target& source) : DeserialisableBase(&source) {}
        String(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        String(const Target& source) : DeserialisableBase(&source) {}
        String(const STRING_TYPE& name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_STRING(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            value<Target>() = StringConvertor<Target>::convert(@LIB_ID@_GET_STRING(json));
        }
        JSON_TYPE to_json() const {
            return StringConvertor<Target>::deconvert(value<Target>());
        }
    };

    template <size_t length>
    struct String<char[length]> : public DeserialisableBase {
        using Target = char[length];

        inline char* value() {
            return reinterpret_cast<char*>(data_ptr);
        }
        inline const char* value() const {
            return reinterpret_cast<const char*>(data_ptr ? data_ptr : info.const_ptr);
        }

        String(char* source) : DeserialisableBase(source) {}
        String(const STRING_TYPE& name, char* source, bool optional = false)
            : DeserialisableBase(source, name, optional) {}
        String(const char* source) : DeserialisableBase(source) {}
        String(const STRING_TYPE& name, const char* source) : DeserialisableBase(source, name) {}

        void assign(const JSON_TYPE& json);
        JSON_TYPE to_json() const {
            return StringConvertor<const char*>::deconvert(value());
        }
    };

    template <typename T, typename StringType>
    struct NullableString : public DeserialisableBase {
        using Target = T;

        NullableString(Target& source) : DeserialisableBase(&source) {}
        NullableString(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        NullableString(const Target& source) : DeserialisableBase(&source) {}
        NullableString(const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_STRING(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            if (!@LIB_ID@_IS_NULL(json))
                value<Target>() = NullableHandler<StringType, T>::convert(
                    StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(json)));
        }
        JSON_TYPE to_json() const {
            if constexpr (std::is_same_v<std::remove_cv_t<std::remove_pointer_t<StringType>>, char>)
                return value<Target>() ? value<Target>() : JSON_TYPE();
            else
                return value<Target>() ? StringConvertor<StringType>::deconvert(*value)
                                       : JSON_TYPE();
        }
    };

    template <typename T, typename StringType>
    struct StringArray : public DeserialisableBase {
        using Target = T;

        StringArray(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        StringArray(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        StringArray(const Target& source) : DeserialisableBase(&source) {}
        StringArray(const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            static_assert(bool(GetArrayInsertWay<T, StringType>::value));
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                if (!@LIB_ID@_IS_STRING(i) && !@LIB_ID@_IS_NULL(i))
                    throw std::ios_base::failure("Type Unmatch!");
                if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                              uint8_t(ArrayInsertWay::Push_Back))
                    value<Target>().push_back(
                        StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i)));
                else if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                   uint8_t(ArrayInsertWay::Append))
                    value<Target>().append(
                        StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i)));
                else if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                   uint8_t(ArrayInsertWay::Insert))
                    value<Target>().insert(
                        StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i)));
            }
        }
        JSON_TYPE to_json() const {
            JSON_ARRAY_TYPE array;
            for (const auto& i : value<Target>())
                @LIB_ID@_ARRAY_APPEND(array, StringConvertor<StringType>::deconvert(i));
            return array;
        }
    };

    template <typename T, typename NullableStringType, typename StringType>
    struct NullableStringArray : public DeserialisableBase {
        using Target = T;

        NullableStringArray(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        NullableStringArray(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        NullableStringArray(const Target& source) : DeserialisableBase(&source) {}
        NullableStringArray(const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : @LIB_ID@_GET_ARRAY(json))
                if (@LIB_ID@_IS_STRING(i)) {
                    if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                  uint8_t(ArrayInsertWay::Push_Back))
                        value<Target>().push_back(
                            NullableHandler<NullableStringType, StringType>::convert(
                                StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i))));
                    else if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                       uint8_t(ArrayInsertWay::Append))
                        value<Target>().append(
                            NullableHandler<NullableStringType, StringType>::convert(
                                StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i))));
                    else if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                       uint8_t(ArrayInsertWay::Insert))
                        value<Target>().insert(
                            NullableHandler<NullableStringType, StringType>::convert(
                                StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i))));
                } else if (@LIB_ID@_IS_NULL(i)) {
                    if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                  uint8_t(ArrayInsertWay::Push_Back))
                        value<Target>().push_back(
                            NullableHandler<NullableStringType, StringType>::make_empty());
                    else if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                       uint8_t(ArrayInsertWay::Append))
                        value<Target>().append(
                            NullableHandler<NullableStringType, StringType>::make_empty());
                    else if constexpr (uint8_t(GetArrayInsertWay<T, StringType>::value) &
                                       uint8_t(ArrayInsertWay::Insert))
                        value<Target>().insert(
                            NullableHandler<NullableStringType, StringType>::make_empty());
                } else
                    throw std::ios_base::failure("Type Unmatch!");
        }
        JSON_TYPE to_json() const {
            JSON_ARRAY_TYPE array;
            for (const auto& i : value<Target>())
                if constexpr (std::is_same_v<std::remove_cv_t<std::remove_pointer_t<StringType>>,
                                             char>)
                    @LIB_ID@_ARRAY_APPEND(array, i ? i : JSON_TYPE());
                else
                    @LIB_ID@_ARRAY_APPEND(array, i ? StringConvertor<StringType>::deconvert(*i) : JSON_TYPE());
            return array;
        }
    };

    template <typename T, typename StringType, std::size_t N>
    struct LimitedStringArray : public StringArray<T, StringType> {
        using Base = StringArray<T, StringType>;
        using Target = T;

        LimitedStringArray(Target& source) : Base(source) {}
        LimitedStringArray(const STRING_TYPE& name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        LimitedStringArray(const Target& source) : Base(source) {}
        LimitedStringArray(const STRING_TYPE& name, const Target& source) : Base(name, source) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            int count = 0;
            for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                if (!@LIB_ID@_IS_STRING(i) && !@LIB_ID@_IS_NULL(i))
                    throw std::ios_base::failure("Type Unmatch!");
                if (count > N - 1)
                    throw std::ios_base::failure("Array Out of Range!");
                DeserialisableBase::value<Target>()[count++] =
                    StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i));
            }
        }
    };

    template <typename T, typename NullableStringType, typename StringType, std::size_t N>
    struct LimitedNullableStringArray
        : public NullableStringArray<T, NullableStringType, StringType> {
        using Base = NullableStringArray<T, NullableStringType, StringType>;
        using Target = T;

        LimitedNullableStringArray(Target& source) : Base(source) {}
        LimitedNullableStringArray(const STRING_TYPE& name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        LimitedNullableStringArray(const Target& source) : Base(source) {}
        LimitedNullableStringArray(const STRING_TYPE& name, const Target& source)
            : Base(name, source) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            int count = 0;
            for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                if (count > N - 1)
                    throw std::ios_base::failure("Array Out of Range!");
                if (!@LIB_ID@_IS_NULL(i))
                    DeserialisableBase::value<Target>()[count++] =
                        NullableHandler<NullableStringType, StringType>::convert(
                            StringConvertor<StringType>::convert(@LIB_ID@_GET_STRING(i)));
                else
                    DeserialisableBase::value<Target>()[count++] =
                        NullableHandler<NullableStringType, StringType>::make_empty();
            }
        }
    };

    template <auto member_offset>
    struct ObjectArrayInfo : public STRING_TYPE {};

    template <typename T, auto... Members>
    struct ObjectArray : public DeserialisableBase {
        using Target = T;
        using ObjectType = typename Deserialisable<Target>::TypeInArray;
        STRING_TYPE identifiers[sizeof...(Members)];

        ObjectArray(T& source, ObjectArrayInfo<Members>&&... members)
            : DeserialisableBase(&source, Trait::ARRAY), identifiers{std::move(members)...} {}
        ObjectArray(const STRING_TYPE& name, T& source, ObjectArrayInfo<Members>&&... members)
            : DeserialisableBase(&source, name), identifiers{std::move(members)...} {}
        ObjectArray(const T& source, ObjectArrayInfo<Members>&&... members)
            : DeserialisableBase(&source), identifiers{std::move(members)...} {}
        ObjectArray(const STRING_TYPE& name, const T& source, ObjectArrayInfo<Members>&&... members)
            : DeserialisableBase(&source, name), identifiers{std::move(members)...} {}

        void assign(const JSON_TYPE& json) {
            static_assert(bool(GetArrayInsertWay<T, ObjectType>::value));
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                if (!@LIB_ID@_IS_OBJECT(i))
                    throw std::ios_base::failure("Type Unmatch!");
                const STRING_TYPE* ptr = identifiers;
                if constexpr (!GetArrayInsertWay<T, ObjectType>::insert_only) {
                    ObjectType& obj = GetArrayInsertWay<T, ObjectType>::push_back(value<Target>());
                    (deserialise_each<DeserialisableType<std::decay_t<decltype(obj.*Members)>>>(
                         @LIB_ID@_GET_OBJECT(i),
                         DeserialisableType<std::decay_t<decltype(obj.*Members)>>(*ptr++,
                                                                                  obj.*Members)),
                     ...);
                } else {
                    ObjectType obj;
                    (deserialise_each<DeserialisableType<std::decay_t<decltype(obj.*Members)>>>(
                         @LIB_ID@_GET_OBJECT(i),
                         DeserialisableType<std::decay_t<decltype(obj.*Members)>>(*ptr++,
                                                                                  obj.*Members)),
                     ...);
                    value<Target>().insert(std::move(obj));
                }
            }
        }
        JSON_TYPE to_json() const {
            JSON_ARRAY_TYPE array;
            for (const auto& i : value<Target>()) {
                const STRING_TYPE* ptr = identifiers;
                (append_each<DeserialisableType<std::decay_t<decltype(i.*Members)>>>(
                     array,
                     DeserialisableType<std::decay_t<decltype(i.*Members)>>(*ptr++, i.*Members)),
                 ...);
            }
            return array;
        }
    };

    template <typename T, typename TypeInArray>
    struct Array : public DeserialisableBase {
        using Target = T;
        using Prototype = DeserialisableType<TypeInArray>;

        Array(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        Array(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Array(const Target& source) : DeserialisableBase(&source) {}
        Array(const STRING_TYPE& name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            static_assert(bool(GetArrayInsertWay<T, TypeInArray>::value));
            if (!QT_IS_ARRAY(json) && !QT_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : QT_GET_ARRAY(json)) {
                if constexpr (!GetArrayInsertWay<T, TypeInArray>::insert_only) {
                    Prototype deserialiser(
                        GetArrayInsertWay<T, TypeInArray>::push_back(value<Target>()));
                    deserialiser.assign(i);
                } else {
                    TypeInArray tmp;
                    Prototype deserialiser(tmp);
                    deserialiser.assign(i);
                    value<Target>().insert(std::move(tmp));
                }
            }
        }
        JSON_TYPE to_json() const {
            JSON_ARRAY_TYPE array;
            for (const auto& i : value<Target>()) {
                Prototype serialiser(i);
                @LIB_ID@_ARRAY_APPEND(array, serialiser.to_json());
            }
            return array;
        }
    };

    template <typename T, typename TypeInArray, std::size_t N>
    struct LimitedArray : public Array<T, TypeInArray> {
        using Base = Array<T, TypeInArray>;
        using Target = T;
        using Prototype = DeserialisableType<TypeInArray>;

        LimitedArray(Target& source) : Base(source) {}
        LimitedArray(const STRING_TYPE& name, Target& source, bool optional = false)
            : Base(name, source, optional) {}
        LimitedArray(const Target& source) : Base(source) {}
        LimitedArray(const STRING_TYPE& name, const Target& source)
            : Base(name, source) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            if constexpr (bool(GetArrayInsertWay<T, TypeInArray>::value))
                for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                    if (DeserialisableBase::value<Target>().size() == N)
                        throw std::ios_base::failure("Array Out of Range!");
                    if constexpr (!GetArrayInsertWay<T, TypeInArray>::insert_only) {
                        Prototype deserialiser(GetArrayInsertWay<T, TypeInArray>::push_back(
                            DeserialisableBase::value<Target>()));
                        deserialiser.assign(i);
                    } else {
                        TypeInArray tmp;
                        Prototype deserialiser(tmp);
                        deserialiser.assign(i);
                        DeserialisableBase::value<Target>().insert(std::move(tmp));
                    }
                }
            else {
                int count = 0;
                for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                    if (count > N - 1)
                        throw std::ios_base::failure("Array Out of Range!");
                    Prototype deserialiser(DeserialisableBase::value<Target>()[count++]);
                    deserialiser.assign(i);
                }
            }
        }
    };

    template <typename T, typename TypeInNullable>
    struct Nullable : public DeserialisableBase {
        using Target = T;

        Nullable(Target& source) : DeserialisableBase(&source) {}
        Nullable(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Nullable(const Target& source) : DeserialisableBase(&source) {}
        Nullable(const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (@LIB_ID@_IS_NULL(json)) {
                value<Target>() = NullableHandler<TypeInNullable, Target>::make_empty();
                return;
            }
            TypeInNullable tmp;
            DeserialisableType<TypeInNullable> deserialiser(tmp);
            deserialiser.assign(json);
            value<Target>() = NullableHandler<TypeInNullable, Target>::convert(tmp);
        }
        JSON_TYPE to_json() const {
            return value<Target>() ? DeserialisableType<TypeInNullable>(*value<Target>()).to_json()
                                   : JSON_TYPE();
        }
    };

    template <typename T, typename As>
    struct EnumAs : public DeserialisableType<As> {
        using Target = T;

        EnumAs(Target& source) : DeserialisableType<As>(reinterpret_cast<As&>(source)) {}
        EnumAs(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableType<As>(name, reinterpret_cast<As&>(source), optional) {}
        EnumAs(const Target& source)
            : DeserialisableType<As>(reinterpret_cast<const As&>(source)) {}
        EnumAs(const STRING_TYPE& name, const Target& source)
            : DeserialisableType<As>(name, reinterpret_cast<const As&>(source)) {}
    };

    template <typename T, const char* json_name, auto member_offset>
    struct Customised {
        using Type = DeserialisableType<T>;
    };

    template <typename T, const char* json_name, size_t json_name_length, auto member_offset,
              bool optional_member = false,
              typename Custom = typename Customised<T, json_name, member_offset>::Type>
    struct ReinforcedInfo {
        using Type = T;
        using Prototype = Custom;
        static constexpr const char* name = json_name;
        static constexpr size_t name_length = json_name_length;
        static constexpr auto member_ptr = member_offset;
        static constexpr bool optional = optional_member;
    };

    template <typename ObjectType, typename... MemberInfo>
    struct Object : public DeserialisableBase {
        using Target = ObjectType;

        Object(Target& source) : DeserialisableBase(&source, Trait::OBJECT) {}
        Object(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Object(const Target& source) : DeserialisableBase(&source) {}
        Object(const STRING_TYPE& name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_OBJECT(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            (deserialise_each<typename MemberInfo::Prototype>(
                 @LIB_ID@_GET_OBJECT(json),
                 typename MemberInfo::Prototype(MemberInfo::name,
                                                value<Target>().*MemberInfo::member_ptr)),
             ...);
        }
        JSON_TYPE to_json() const {
            JSON_OBJECT_TYPE obj;
            (insert_each<const typename MemberInfo::Prototype>(
                 obj, typename MemberInfo::Prototype(MemberInfo::name,
                                                     value<Target>().*MemberInfo::member_ptr)),
             ...);
            return obj;
        }
    };

    template <class Base, class Derived, typename... MemberInfo>
    struct DerivedObject : public DeserialisableType<Base> {
        using Target = Derived;

        DerivedObject(Target& source) : DeserialisableType<Base>(source) {}
        DerivedObject(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableType<Base>(name, source, optional) {}
        DerivedObject(const Target& source) : DeserialisableType<Base>(source) {}
        DerivedObject(const STRING_TYPE& name, const Target& source)
            : DeserialisableType<Base>(name, source) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_OBJECT(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            DeserialisableType<Base>::assign(json);
            (deserialise_each<typename MemberInfo::Prototype>(
                 @LIB_ID@_GET_OBJECT(json),
                 typename MemberInfo::Prototype(MemberInfo::name,
                                                DeserialisableBase::value<Target>().*
                                                    MemberInfo::member_ptr)),
             ...);
        }

        JSON_TYPE to_json() const {
            auto obj = @LIB_ID@_GET_OBJECT(DeserialisableType<Base>::to_json());
            (insert_each<const typename MemberInfo::Prototype>(
                 obj, typename MemberInfo::Prototype(MemberInfo::name,
                                                     DeserialisableBase::value<Target>().*
                                                         MemberInfo::member_ptr)),
             ...);
            return obj;
        }
    };

    template <typename ObjectType>
    struct SelfDeserialisableObject : public DeserialisableBase {
        using Target = ObjectType;

        SelfDeserialisableObject(Target& source) : DeserialisableBase(&source, Trait::OBJECT) {}
        SelfDeserialisableObject(const STRING_TYPE& name, ObjectType& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        SelfDeserialisableObject(const Target& source) : DeserialisableBase(&source) {}
        SelfDeserialisableObject(const STRING_TYPE& name, const ObjectType& source)
            : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_OBJECT(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            value<Target>() = std::move(Target(@LIB_ID@_GET_OBJECT(json)));
        }
        JSON_TYPE to_json() const {
            return value<Target>().to_json();
        }
    };

    template <typename T, typename KeyType, typename ValueType>
    struct ObjectMap : public DeserialisableBase {
        using Target = T;
        STRING_TYPE key;

        ObjectMap(Target& source, const STRING_TYPE& key_name)
            : DeserialisableBase(&source, Trait::ARRAY), key(key_name) {}
        ObjectMap(const STRING_TYPE& name, Target& source, const STRING_TYPE& key_name)
            : DeserialisableBase(&source, name), key(key_name) {}
        ObjectMap(const Target& source, const STRING_TYPE& key_name)
            : DeserialisableBase(&source), key(key_name) {}
        ObjectMap(const STRING_TYPE& name, const Target& source, const STRING_TYPE& key_name)
            : DeserialisableBase(&source, name), key(key_name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& i : @LIB_ID@_GET_ARRAY(json)) {
                const auto& obj = @LIB_ID@_GET_OBJECT(i);
                if (!@LIB_ID@_OBJECT_CONTAINS_KEY(obj, key))
                    throw std::ios_base::failure("Type Unmatch!");
                KeyType key_field;
                DeserialisableType<KeyType> key_deserialiser(key_field);
                key_deserialiser.assign(obj[key]);
                ValueType value_obj;
                DeserialisableType<ValueType> value_deserialiser(value_obj);
                value_deserialiser.assign(obj);
                value<Target>()[key_field] = std::move(value_obj);
            }
        }
        JSON_TYPE to_json() const {
            JSON_ARRAY_TYPE array;
            for (const auto& [key_, value_] : value<Target>()) {
                DeserialisableType<ValueType> value_deserialiser(value_);
                auto obj = @LIB_ID@_GET_OBJECT(value_deserialiser.to_json());
                DeserialisableType<KeyType> key_deserialiser(key_);
                obj.insert(key, key_deserialiser.to_json());
                @LIB_ID@_ARRAY_APPEND(array, std::move(obj));
            }
            return array;
        }
    };

    template <typename T, typename KeyType, typename ValueType>
    struct Map : public DeserialisableBase {
        using Target = T;

        Map(Target& source) : DeserialisableBase(&source, Trait::ARRAY) {}
        Map(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        Map(const Target& source) : DeserialisableBase(&source) {}
        Map(const STRING_TYPE& name, const Target& source) : DeserialisableBase(&source, name) {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_ARRAY(json) && !@LIB_ID@_IS_NULL(json))
                throw std::ios_base::failure("Type Unmatch!");
            for (const auto& [_key, _value] : @LIB_ID@_GET_OBJECT(json)) {
                KeyType key;
                ValueType value_;
                DeserialisableType<KeyType> key_deserialiser(key);
                DeserialisableType<ValueType> value_deserialiser(value_);
                key_deserialiser.assign(_key);
                value_deserialiser.assign(_value);
                value<Target>()[key] = std::move(value_);
            }
        }
        JSON_TYPE to_json() const {
            JSON_OBJECT_TYPE obj;
            for (const auto& [key, value] : value<Target>()) {
                DeserialisableType<KeyType> key_deserialiser(key);
                DeserialisableType<ValueType> value_deserialiser(value);
                obj.insert(key_deserialiser.to_json(), value_deserialiser.to_json());
            }
            return obj;
        }
    };

    template <typename T, typename Type1, typename Type2>
    struct Pair : public DeserialisableBase {
        using Target = T;
        STRING_TYPE name[2];

        Pair(Target& source, const STRING_TYPE& name1, const STRING_TYPE& name2)
            : DeserialisableBase(&source, Trait::OBJECT), name{name1, name2} {}
        Pair(const STRING_TYPE& json_name, Target& source, const STRING_TYPE& name1,
             const STRING_TYPE& name2)
            : DeserialisableBase(&source, json_name), name{name1, name2} {}
        Pair(const Target& source, const STRING_TYPE& name1, const STRING_TYPE& name2)
            : DeserialisableBase(&source), name{name1, name2} {}
        Pair(const STRING_TYPE& json_name, const Target& source, const STRING_TYPE& name1,
             const STRING_TYPE& name2)
            : DeserialisableBase(&source, json_name), name{name1, name2} {}

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_OBJECT(json))
                throw std::ios_base::failure("Type Unmatch!");
            Type1& element1 = value<Target>().first;
            Type2& element2 = value<Target>().second;
            DeserialisableType<Type1> deserialiser1(element1);
            DeserialisableType<Type2> deserialiser2(element2);
            deserialiser1.assign(@LIB_ID@_GET_OBJECT(json)[name[0]]);
            deserialiser2.assign(@LIB_ID@_GET_OBJECT(json)[name[1]]);
        }
        JSON_TYPE to_json() const {
            JSON_OBJECT_TYPE pair;
            const DeserialisableType<Type1> serialiser1(value<Target>().first);
            const DeserialisableType<Type2> serialiser2(value<Target>().second);
            pair.insert(name[0], serialiser1.to_json());
            pair.insert(name[1], serialiser2.to_json());
            return pair;
        }
    };

    template <typename Function>
    struct ArgTypeDeduction {
        using Type = typename ArgTypeDeduction<decltype(&Function::operator())>::Type;
    };

    template <typename R, class C, typename Arg>
    struct ArgTypeDeduction<R (C::*)(Arg) const> {
        using Type = Arg;
    };

    template <typename Des, typename ConvertFunctor,
              typename BasicType = std::decay_t<typename ArgTypeDeduction<decltype(std::function(
                  std::declval<ConvertFunctor>()))>::Type>>
    struct DeserialiseOnlyConvertor : decltype(std::function(std::declval<ConvertFunctor>())) {
        using Type = BasicType;
        using Target = std::decay_t<Des>;
        using Source = std::decay_t<BasicType>;
        using FunctionType = decltype(std::function(std::declval<ConvertFunctor>()));

        template <typename T>
        DeserialiseOnlyConvertor(T&& convertor) : FunctionType(convertor) {}
    };

    template <typename Convertor>
    class DeserialiseOnlyExtension : public DeserialisableBase {
    public:
        using Type = DeserialisableType<typename Convertor::Type>;
        using Target = typename Convertor::Target;
        using Source = typename Convertor::Source;

    protected:
        std::decay_t<Convertor> convertor;

    public:
        template <typename T>
        DeserialiseOnlyExtension(T&& convertor, Target& source)
            : DeserialisableBase(&source), convertor(std::forward<T>(convertor)) {}
        template <typename T>
        DeserialiseOnlyExtension(T&& convertor, const STRING_TYPE& name, Target& source,
                                 bool optional = false)
            : DeserialisableBase(&source, name, optional), convertor(std::forward<T>(convertor)) {}

        void assign(const JSON_TYPE& json) {
            Source tmp;
            Type(tmp).assign(json);
            value<Target>() = convertor(tmp);
        }
    };
    template <typename Des, typename ConvertFunctor>
    DeserialiseOnlyExtension(ConvertFunctor&&, Des&)
        -> DeserialiseOnlyExtension<DeserialiseOnlyConvertor<Des, ConvertFunctor>>;
    template <typename Des, typename ConvertFunctor>
    DeserialiseOnlyExtension(ConvertFunctor&&, const STRING_TYPE&, Des&, bool)
        -> DeserialiseOnlyExtension<DeserialiseOnlyConvertor<Des, ConvertFunctor>>;

    template <typename Des, typename ConvertFunctor,
              typename BasicType =
                  std::decay_t<decltype(std::declval<ConvertFunctor>()(std::declval<Des>()))>>
    struct SerialiseOnlyConvertor : decltype(std::function(std::declval<ConvertFunctor>())) {
        using Type = BasicType;
        using Target = std::decay_t<Des>;
        using Source = std::decay_t<BasicType>;
        using FunctionType = decltype(std::function(std::declval<ConvertFunctor>()));

        template <typename T>
        SerialiseOnlyConvertor(T&& convertor) : FunctionType(convertor) {}
    };

    template <typename Convertor>
    class SerialiseOnlyExtension : public DeserialisableBase {
    public:
        using Type = DeserialisableType<typename Convertor::Type>;
        using Target = typename Convertor::Target;
        using Source = typename Convertor::Source;

    protected:
        std::decay_t<Convertor> convertor;

    public:
        template <typename T>
        SerialiseOnlyExtension(T&& convertor, const Target& source)
            : DeserialisableBase(&source), convertor(std::forward<T>(convertor)) {}
        template <typename T>
        SerialiseOnlyExtension(T&& convertor, const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name), convertor(std::forward<T>(convertor)) {}

        JSON_TYPE to_json() const {
            auto tmp = convertor(value<Target>());
            return Type(tmp).to_json();
        }
    };

    template <typename Des, typename ConvertFunctor = Des(const JSON_TYPE&),
              typename DeconvertFunctor = JSON_TYPE(const Des&),
              typename BasicType = decltype(std::declval<DeconvertFunctor>()(std::declval<Des>()))>
    struct Convertor {
        using Type = BasicType;
        using Target = std::decay_t<Des>;
        using Source = std::decay_t<BasicType>;
        DeserialiseOnlyConvertor<Des, ConvertFunctor, BasicType> convertor;
        SerialiseOnlyConvertor<Des, DeconvertFunctor, BasicType> deconvertor;

        template <typename U, typename V>
        Convertor(U&& convertor, V&& deconvertor)
            : convertor(std::forward<U>(convertor)), deconvertor(std::forward<V>(deconvertor)) {}
        explicit Convertor()
            : convertor{[](const JSON_TYPE& json) {
                  using T = DeserialisableType<Des>;
                  Des result;
                  T(result).assign(json);
                  return result;
              }},
              deconvertor{[](const Des& src) {
                  using T = DeserialisableType<Des>;
                  return T(src).to_json();
              }} {}
    };

    template <typename Convertor>
    class Extension : public DeserialisableBase {
    public:
        using Type = DeserialisableType<typename Convertor::Type>;
        using Target = typename Convertor::Target;
        using Source = typename Convertor::Source;

    protected:
        std::decay_t<Convertor> convertor;

    public:
        template <typename U, typename V>
        Extension(U&& convertor, V&& deconvertor, Target& source)
            : DeserialisableBase(&source),
              convertor(std::forward<U>(convertor), std::forward<V>(deconvertor)) {}
        template <typename U, typename V>
        Extension(U&& convertor, V&& deconvertor, const STRING_TYPE& name, Target& source,
                  bool optional = false)
            : DeserialisableBase(&source, name, optional),
              convertor(std::forward<U>(convertor), std::forward<V>(deconvertor)) {}
        template <typename U, typename V>
        Extension(U&& convertor, V&& deconvertor, const Target& source)
            : DeserialisableBase(&source),
              convertor(std::forward<U>(convertor), std::forward<V>(deconvertor)) {}
        template <typename U, typename V>
        Extension(U&& convertor, V&& deconvertor, const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name),
              convertor(std::forward<U>(convertor), std::forward<V>(deconvertor)) {}

        void assign(const JSON_TYPE& json) {
            Source tmp;
            Type(tmp).assign(json);
            value<Target>() = convertor.convertor(tmp);
        }
        JSON_TYPE to_json() const {
            auto tmp = convertor.deconvertor(value<Target>());
            return Type(tmp).to_json();
        }
    };

    template <typename Standard, typename Tuple, int current = 0,
              typename Result = typename ConstexprConstantArray<Standard::length, -1>::Type,
              bool = Tuple::length <= 1>
    struct ConvertorAdapterReorganise;

    template <typename... Targets, int current, typename Last, typename Current, typename... Left>
    struct ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<Current, Left...>, current,
                                      Last, false> {
        static constexpr int index =
            FindType<TypeTuple<Targets...>, typename Current::Target>::index;
        using Next = ConvertorAdapterReorganise<
            TypeTuple<Targets...>, TypeTuple<Left...>, current + 1,
            typename ConstexprArrayPackAlter<index, current, Last>::Type>;
        using Type = typename Next::Type;
    };

    template <typename... Targets, int current, typename Last, typename Current>
    struct ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<Current>, current, Last,
                                      true> {
        static constexpr int index =
            FindType<TypeTuple<Targets...>, typename Current::Target>::index;
        using Type = typename ConstexprArrayPackAlter<index, current, Last>::Type;
    };

    template <typename... Targets, typename Result>
    struct ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<void>, 0, Result, true> {
        using Type = Result;
    };

    template <int N, typename Target, typename Given>
    inline Convertor<Target> ConvertorGenerator(Given& given) {
        if constexpr (N == -1)
            return std::move(Convertor<Target>());
        else
            return std::move(given.template get<N>());
    };

    template <typename Target, typename Inc, typename... Given>
    struct ConvertorAdapter;

    template <typename... Targets, int... pack, typename... Given>
    struct ConvertorAdapter<std::variant<Targets...>, ConstexprArrayPack<pack...>, Given...> {
        using Array =
            typename ConvertorAdapterReorganise<TypeTuple<Targets...>, TypeTuple<Given...>>::Type;
        using Tuple = TypeTuple<Given...>;
        using Target = TypeTuple<Targets...>;
        StaticTuple<Convertor<Given>...> givens;
        StaticTuple<Convertor<Targets>...> convertors;

        ConvertorAdapter(Given&... given)
            : givens(given...),
              convertors(
                  ConvertorGenerator<Array::value[pack], typename GetType<pack, Target>::Type>(
                      givens)...) {}
    };

    template <typename Variant>
    struct GetNum;

    template <typename... Types>
    struct GetNum<std::variant<Types...>> {
        constexpr static int value = sizeof...(Types);
    };

    template <typename Target,
              typename Inc = typename ConstexprIncArray<GetNum<Target>::value>::Type>
    class VarientObject;

    template <typename... Targets, typename Deductor, typename... Given_Convertors>
    VarientObject(std::variant<Targets...>&, const STRING_TYPE&, Deductor&&, Given_Convertors&&...)
        -> VarientObject<std::variant<Targets...>>;
    template <typename... Targets, typename Deductor, typename... Given_Convertors>
    VarientObject(const STRING_TYPE&, std::variant<Targets...>&, const STRING_TYPE&, Deductor&&,
                  Given_Convertors&&...) -> VarientObject<std::variant<Targets...>>;

    template <typename... Targets, int... pack>
    class VarientObject<std::variant<Targets...>, ConstexprArrayPack<pack...>>
        : public DeserialisableBase {
    protected:
        using Target = std::variant<Targets...>;
        STRING_TYPE identifier;
        std::function<int(const JSON_TYPE&)> deductor;
        StaticTuple<Convertor<Targets>...> convertors;

    public:
        template <typename Deductor, typename... Given_Convertors>
        VarientObject(Target& source, const STRING_TYPE& identifier, Deductor&& deduction,
                      Given_Convertors&&... convertors)
            : DeserialisableBase(&source, Trait::OBJECT), identifier(identifier),
              deductor(std::forward<Deductor>(deduction)),
              convertors(ConvertorAdapter<Target, ConstexprArrayPack<pack...>, Given_Convertors...>(
                             convertors...)
                             .convertors) {}
        template <typename Deductor, typename... Given_Convertors>
        VarientObject(const STRING_TYPE& name, Target& source, const STRING_TYPE& identifier,
                      Deductor&& deduction, Given_Convertors&&... convertors)
            : DeserialisableBase(&source, name), identifier(identifier),
              deductor(std::forward<Deductor>(deduction)),
              convertors(ConvertorAdapter<Target, ConstexprArrayPack<pack...>, Given_Convertors...>(
                             convertors...)
                             .convertors) {}

        template <int N>
        void assign_if_eq(int index, const JSON_OBJECT_TYPE& obj) {
            if (N == index)
                value<Target>().emplace<N>(convertors.get<N>().convertor(obj));
        }
        template <int N>
        void serialise_if_eq(int index, JSON_TYPE& json) {
            if (N == index)
                json = convertors.get<N>().deconvertor(json);
        }

        void assign(const JSON_TYPE& json) {
            if (!@LIB_ID@_IS_OBJECT(json) || !@LIB_ID@_GET_OBJECT(json).contains(identifier))
                throw std::ios_base::failure("Type Unmatch!");
            const auto& obj = @LIB_ID@_GET_OBJECT(json);
            int index = deductor(obj[identifier]);
            if (index == -1)
                throw std::ios_base::failure("Type Unmatch!");
            (assign_if_eq<pack>(index, obj), ...);
        }
        JSON_TYPE to_json() const {
            JSON_TYPE result;
            int index = value<Target>().index();
            (serialise_if_eq<pack>(index, result), ...);
        }
    };

    class JSONWrap : public DeserialisableBase {
        using Target = JSON_TYPE;

    public:
        JSONWrap(Target& source) : DeserialisableBase(&source) {}
        JSONWrap(const STRING_TYPE& name, Target& source, bool optional = false)
            : DeserialisableBase(&source, name, optional) {}
        JSONWrap(const Target& source) : DeserialisableBase(&source) {}
        JSONWrap(const STRING_TYPE& name, const Target& source)
            : DeserialisableBase(&source, name) {}

        inline void assign(const JSON_TYPE& json) {
            value<Target>() = json;
        }
        inline JSON_TYPE to_json() const {
            return value<Target>();
        }
    };

    template <typename T, typename Prototype = DeserialisableType<T>>
    class EndoFunctor : public Prototype {
        std::function<void(T&)> functor;

    public:
        template <typename Functor>
        EndoFunctor(Functor&& f, T& source) : Prototype(source), functor(f) {}
        template <typename Functor>
        EndoFunctor(Functor&& f, const STRING_TYPE& json_name, T& source, bool optional = false)
            : Prototype(json_name, source, optional), functor(f) {}

        void assign(const JSON_TYPE& json) {
            Prototype::assign(json);
            functor(Prototype::value);
        }
    };

    template <typename TypeInRef, typename Prototype = DeserialisableType<std::decay_t<TypeInRef>>>
    using RefWrap = Prototype;
    
    template <typename Any>
    struct Deserialisable<Any&> {
        using Type = RefWrap<std::decay_t<Any>>;
    };
    
    template <typename Any>
    struct Deserialisable<Any&&> {
        using Type = RefWrap<std::decay_t<Any>>;
    };
    
    template <typename Any>
    struct Deserialisable<const Any&> {
        using Type = RefWrap<std::decay_t<Any>>;
    };

    template <typename Container, typename T>
    struct ArrayTypeInfo {
        using ArrayType = Container;
        using TypeInArray = T;
    };

    template <typename Container, typename Key, typename Value>
    struct MapTypeInfo {
        using MapType = Container;
        using KeyType = Key;
        using ValueType = Value;
        using _OBJECT_MAP_ = ObjectMap<Container, KeyType, ValueType>;
    };

    template <typename Any>
    struct _Deserialisable<Any, false, -1, void, -1, void, -1> {
        using Type = _DeserialisableType<Any, false, -1, void, is_nullable<Any>::value,
                                         typename is_nullable<Any>::Type, -1>;
    };

    template <typename Any>
    struct _Deserialisable<Any, false, -1, void, false, void, -1> {
        using Type = _DeserialisableType<Any, false, -1, void, false, void, is_string<Any>::value>;
    };

    template <typename T, typename TypeInNullable>
    struct _Deserialisable<T, false, -1, void, true, TypeInNullable, -1> {
        using Type = _DeserialisableType<T, false, -1, void, true, TypeInNullable,
                                         is_string<TypeInNullable>::value>;
    };

    template <typename T, typename TypeInArray>
    struct _Deserialisable<T, true, -1, TypeInArray, -1, void, -1> {
        using Type = _DeserialisableType<T, true, -1, TypeInArray, is_nullable<TypeInArray>::value,
                                         typename is_nullable<TypeInArray>::Type, -1>;
    };

    template <typename T, typename TypeInArray>
    struct _Deserialisable<T, true, -1, TypeInArray, false, void, -1> {
        using Type = _DeserialisableType<T, true, -1, TypeInArray, false, void,
                                         is_string<TypeInArray>::value>;
    };

    template <typename T, typename TypeInArray, typename TypeInNullable>
    struct _Deserialisable<T, true, -1, TypeInArray, true, TypeInNullable, -1> {
        using Type = _DeserialisableType<T, true, -1, TypeInArray, true, TypeInNullable,
                                         is_string<TypeInNullable>::value>;
    };

    template <typename StringType>
    struct _Deserialisable<StringType, false, -1, void, false, void, true> {
        using Type = String<StringType>;
    };

    template <typename T, typename StringType>
    struct _Deserialisable<T, false, -1, void, true, StringType, true> {
        using Type = NullableString<T, StringType>;
    };

    template <typename T, typename TypeInNullable>
    struct _Deserialisable<T, false, -1, void, true, TypeInNullable, false> {
        using Type = Nullable<T, TypeInNullable>;
    };

    template <typename TypeInArray, std::size_t N>
    struct Deserialisable<TypeInArray[N]> {
        using Type = _DeserialisableType<TypeInArray[N], true, N, TypeInArray>;
    };

    template <typename T, typename StringType>
    struct _Deserialisable<T, true, -1, StringType, false, void, true> {
        using Type = StringArray<T, StringType>;
    };

    template <typename T, typename Nullable, typename StringType>
    struct _Deserialisable<T, true, -1, Nullable, true, StringType, true> {
        using Type = NullableStringArray<T, Nullable, StringType>;
    };

    template <typename ArrayType, typename T>
    struct _Deserialisable<ArrayType, true, -1, T, false, void, false> {
        using Type = Array<ArrayType, T>;
    };

    template <typename ArrayType, typename T, int N>
    struct _Deserialisable<ArrayType, true, N, T, -1, void, -1> {
        using Type = LimitedArray<ArrayType, T, N>;
    };

    template <typename T, typename StringType, int N>
    struct _Deserialisable<T, true, N, StringType, false, void, true> {
        using Type = LimitedStringArray<T, StringType, N>;
    };

    template <typename T, typename Nullable, typename StringType, int N>
    struct _Deserialisable<T, true, N, Nullable, true, StringType, true> {
        using Type = LimitedNullableStringArray<T, Nullable, StringType, N>;
    };

    template <>
    struct Deserialisable<JSON_TYPE> {
        using Type = JSONWrap;
    };

    template <>
    struct Deserialisable<bool> {
        using Type = Boolean;
    };

    template <>
    struct Deserialisable<int> {
        using Type = Integer<true, sizeof(int)>;
    };

    template <>
    struct Deserialisable<unsigned> {
        using Type = Integer<false, sizeof(unsigned)>;
    };

    template <>
    struct Deserialisable<double> {
        using Type = Real<double>;
    };

    template <size_t length>
    struct Deserialisable<char[length]> {
        using Type = String<char[length]>;
    };

    template <typename TypeInArray, std::size_t N>
    struct Deserialisable<std::array<TypeInArray, N>> {
        using Type = _DeserialisableType<std::array<TypeInArray, N>, true, N, TypeInArray>;
    };

    template <typename T, typename Alloc>
    struct Deserialisable<std::vector<T, Alloc>> : public ArrayTypeInfo<std::vector<T, Alloc>, T> {
        using Type = _DeserialisableType<std::vector<T, Alloc>, true, -1, T>;
    };

    template <typename T, typename Alloc>
    struct Deserialisable<std::list<T, Alloc>> : public ArrayTypeInfo<std::list<T, Alloc>, T> {
        using Type = _DeserialisableType<std::list<T, Alloc>, true, -1, T>;
    };

    template <typename T, typename Comp, typename Alloc>
    struct Deserialisable<std::set<T, Comp, Alloc>>
        : public ArrayTypeInfo<std::set<T, Comp, Alloc>, T> {
        using Type = _DeserialisableType<std::set<T, Comp, Alloc>, true, -1, T>;
    };

    template <typename Key, typename Value, typename Comp, typename Alloc>
    struct Deserialisable<std::map<Key, Value, Comp, Alloc>>
        : public MapTypeInfo<std::map<Key, Value, Comp, Alloc>, Key, Value> {
        using Type = Map<std::map<Key, Value, Comp, Alloc>, Key, Value>;
    };

    template <typename First, typename Second>
    struct Deserialisable<std::pair<First, Second>> {
        using Type = Pair<std::pair<First, Second>, First, Second>;
    };
} // namespace @LIB_ID@
} // namespace JsonDeserialise

// Global Library Irrelevant Macro
#define set_object_alias(object_type, alias)                                                       \
    namespace JsonDeserialise {                                                                    \
        using alias = ::object_type;                                                               \
    };
#define register_object_member(object_type, json_name, member_name)                                \
    namespace JsonDeserialise {                                                                    \
        constexpr char object_type##_##member_name[] = json_name;                                  \
    };

// Local
#define @lib@_declare_top_deserialiser(data_name, var_name)                                        \
    JsonDeserialise::@LIB_ID@::DeserialisableType<decltype(data_name)> var_name(data_name);
#define @lib@_declare_deserialiser(json_name, data_name, var_name)                                 \
    JsonDeserialise::@LIB_ID@::DeserialisableType<decltype(data_name)> var_name(json_name,         \
                                                                                data_name);
#define @lib@_declare_top_serialiser(data_name, var_name)                                          \
    JsonDeserialise::@LIB_ID@::DeserialisableType<decltype(data_name)> var_name(                   \
        std::as_const(data_name));
#define @lib@_declare_serialiser(json_name, data_name, var_name)                                   \
    JsonDeserialise::@LIB_ID@::DeserialisableType<decltype(data_name)> var_name(                   \
        json_name, std::as_const(data_name));
#define @lib@_declare_extension_deserialiser(json_name, data_name, var_name, convertor,            \
                                             deconvertor)                                          \
    JsonDeserialise::@LIB_ID@::Extension<JsonDeserialise::@LIB_ID@::Convertor<                     \
        decltype(data_name), decltype(convertor), decltype(deconvertor)>>                          \
        var_name((convertor), (deconvertor), json_name, data_name);
#define @lib@_declare_one_direction_extension_deserialiser(json_name, data_name, var_name,         \
                                                           convertor)                              \
    JsonDeserialise::@LIB_ID@::DeserialiseOnlyExtension var_name((convertor), json_name, data_name);
#define @lib@_declare_one_direction_extension_serialiser(json_name, data_name, var_name,           \
                                                         deconvertor)                              \
    JsonDeserialise::@LIB_ID@::SerialiseOnlyExtension<                                             \
        JsonDeserialise::@LIB_ID@::SerialiseOnlyConvertor<decltype(data_name),                     \
                                                          decltype(deconvertor)>>                  \
        var_name((deconvertor), json_name, std::as_const(data_name));
#define @lib@_declare_top_map_of_object_object_deserialiser(data_name, key_name, var_name)         \
    typename JsonDeserialise::@LIB_ID@::Deserialisable<decltype(data_name)>::_OBJECT_MAP_          \
        var_name(data_name, key_name);
#define @lib@_declare_map_of_object_deserialiser(json_name, data_name, key_name, var_name)         \
    typename JsonDeserialise::@LIB_ID@::Deserialisable<decltype(data_name)>::_OBJECT_MAP_          \
        var_name(json_name, data_name, key_name);
#define @lib@_declare_top_pair_deserialiser(json_name1, json_name2, data_name, var_name)           \
    JsonDeserialise::@LIB_ID@::DeserialisableType<decltype(data_name)> var_name(                   \
        data_name, json_name1, json_name2);
#define @lib@_declare_pair_deserialiser(json_name, json_name1, json_name2, data_name, var_name)    \
    JsonDeserialise::@LIB_ID@::DeserialisableType<decltype(data_name)> var_name(                   \
        json_name, data_name, json_name1, json_name2);
#define @lib@_declare_top_object_deserialiser(var_name, ...)                                       \
    JsonDeserialise::@LIB_ID@::JsonDeserialiser var_name(__VA_ARGS__);
#define @lib@_declare_top_array_of_object_deserialiser(data_name, var_name, ...)                   \
    JsonDeserialise::@LIB_ID@::ObjectArray var_name(data_name, __VA_ARGS__);
#define @lib@_declare_array_of_object_deserialiser(json_name, data_name, var_name, ...)            \
    JsonDeserialise::@LIB_ID@::ObjectArray var_name(json_name, data_name, __VA_ARGS__);
#define @lib@_array_field(object_type, json_name, member_name)                                     \
    static_cast<JsonDeserialise::@LIB_ID@::ObjectArrayInfo<&object_type::member_name>&&>(          \
        @LIB_ID@##_##STRING_LITERAL_WRAP(json_name))

// Global
#define @lib@_object_member(object_type, member_name)                                              \
    JsonDeserialise::@LIB_ID@::ReinforcedInfo<                                                     \
        decltype(((object_type*)nullptr)->member_name),                                            \
        JsonDeserialise::object_type##_##member_name,                                              \
        sizeof(JsonDeserialise::object_type##_##member_name), &object_type::member_name>
#define @lib@_optional_object_member(object_type, member_name)                                     \
    JsonDeserialise::@LIB_ID@::ReinforcedInfo<                                                     \
        decltype(((object_type*)nullptr)->member_name),                                            \
        JsonDeserialise::object_type##_##member_name,                                              \
        sizeof(JsonDeserialise::object_type##_##member_name), &object_type::member_name, true>
#define @lib@_declare_object(object_type, ...)                                                     \
    template <>                                                                                    \
    struct JsonDeserialise::@LIB_ID@::Deserialisable<object_type> {                                \
        using Type = Object<object_type, __VA_ARGS__>;                                             \
    };
#define @lib@_declare_class_with_json_constructor_and_serialiser(object_type)                      \
    template <>                                                                                    \
    struct JsonDeserialise::@LIB_ID@::Deserialisable<object_type> {                                \
        using Type = SelfDeserialisableObject<object_type>;                                        \
    };
#define @lib@_declare_object_with_base_class(object_type, base_type, ...)                          \
    template <>                                                                                    \
    struct JsonDeserialise::@LIB_ID@::Deserialisable<object_type> {                                \
        using Type = DerivedObject<base_type, object_type, __VA_ARGS__>;                           \
    };
#define @lib@_declare_enum_as(type_name, as)                                                       \
    template <>                                                                                    \
    struct JsonDeserialise::@LIB_ID@::Deserialisable<type_name> {                                  \
        using Type = JsonDeserialise::@LIB_ID@::EnumAs<type_name, as>;                             \
    };
#define @lib@_declare_global_extension(target_type, json_type, convertor, deconvertor)             \
    namespace JsonDeserialise {                                                                    \
        namespace @LIB_ID@ {                                                                       \
            using target_type##_##json_type##_##GlobalExtension_Base_Convertor_ =                  \
                Convertor<target_type, decltype(convertor), decltype(deconvertor), json_type>;     \
            using target_type##_##json_type##_##GlobalExtension_Base_ =                            \
                Extension<target_type##_##json_type##_##GlobalExtension_Base_Convertor_>;          \
            struct target_type##_##json_type##_##GlobalExtension_                                  \
                : public target_type##_##json_type##_##GlobalExtension_Base_ {                     \
                using Base = target_type##_##json_type##_##GlobalExtension_Base_;                  \
                template <typename... Args>                                                        \
                target_type##_##json_type##_##GlobalExtension_(Args&&... args)                     \
                    : Base((convertor), (deconvertor), args...) {}                                 \
            };                                                                                     \
            template <>                                                                            \
            struct Deserialisable<target_type> {                                                   \
                using Type = target_type##_##json_type##_##GlobalExtension_;                       \
            };                                                                                     \
        }                                                                                          \
    }
#define @lib@_declare_extension(name, target_type, json_type, convertor, deconvertor)              \
    namespace JsonDeserialise {                                                                    \
        namespace @LIB_ID@ {                                                                       \
            using name##_##Extension_Base_Convertor_ =                                             \
                Convertor<target_type, decltype(convertor), decltype(deconvertor), json_type>;     \
            using name##_##Extension_Base_ = Extension<name##_##Extension_Base_Convertor_>;        \
            struct name##_##Extension_ : public name##_##Extension_Base_ {                         \
                using Base = name##_##Extension_Base_;                                             \
                template <typename... Args>                                                        \
                name##_##Extension_(Args&&... args) : Base((convertor), (deconvertor), args...) {} \
            };                                                                                     \
        }                                                                                          \
    }
#define @lib@_register_object_member_with_extension(object_type, json_name, member_name,           \
                                                    json_type, convertor, deconvertor)             \
    register_object_member(object_type, json_name, member_name);                                   \
    namespace JsonDeserialise {                                                                    \
        namespace @LIB_ID@ {                                                                       \
            using object_type##_##member_name##_##json_type##_##Extension_Convertor_ =             \
                Convertor<decltype(((object_type*)nullptr)->member_name), decltype(convertor),     \
                          decltype(deconvertor), json_type>;                                       \
            using object_type##_##member_name##_##json_type##_##Extension_Base_ =                  \
                Extension<object_type##_##member_name##_##json_type##_##Extension_Convertor_>;     \
            struct object_type##_##member_name##_##json_type##_##Extension_                        \
                : public object_type##_##member_name##_##json_type##_##Extension_Base_ {           \
                using Base = object_type##_##member_name##_##json_type##_##Extension_Base_;        \
                template <typename... Args>                                                        \
                object_type##_##member_name##_##json_type##_##Extension_(Args&&... args)           \
                    : Base((convertor), (deconvertor), args...) {}                                 \
            };                                                                                     \
        }                                                                                          \
    }                                                                                              \
    template <>                                                                                    \
    struct JsonDeserialise::@LIB_ID@::Customised<decltype(((object_type*)nullptr)->member_name),   \
                                                 JsonDeserialise::object_type##_##member_name,     \
                                                 &object_type::member_name> {                      \
        using Type =                                                                               \
            JsonDeserialise::@LIB_ID@::object_type##_##member_name##_##json_type##_##Extension_;   \
    };
#define @lib@_object_member_with_extension(object_type, member_name, extension)                    \
    JsonDeserialise::@LIB_ID@::ReinforcedInfo<                                                     \
        decltype(((object_type*)nullptr)->member_name),                                            \
        JsonDeserialise::object_type##_##member_name,                                              \
        sizeof(JsonDeserialise::object_type##_##member_name), &object_type::member_name, false,    \
        JsonDeserialise::@LIB_ID@::extension##_##Extension_>
#define @lib@_optional_object_member_with_extension(object_type, member_name, extension)           \
    JsonDeserialise::@LIB_ID@::ReinforcedInfo<                                                     \
        decltype(((object_type*)nullptr)->member_name),                                            \
        JsonDeserialise::object_type##_##member_name,                                              \
        sizeof(JsonDeserialise::object_type##_##member_name), &object_type::member_name, true,     \
        JsonDeserialise::@LIB_ID@::extension##_##Extension_>
#define @lib@_declare_endofunctor(name, type, functor)                                             \
    namespace JsonDeserialise {                                                                    \
        namespace @LIB_ID@ {                                                                       \
            struct name##_##EndoFunctor_ : public EndoFunctor<type> {                              \
                using Base = EndoFunctor<type>;                                                    \
                template <typename... Args>                                                        \
                name##_##EndoFunctor_(Args&&... args) : Base(functor, args...) {}                  \
            };                                                                                     \
        }                                                                                          \
    }
#define @lib@_register_object_member_with_endofunctor(object_type, json_name, member_name,         \
                                                      functor)                                     \
    register_object_member(object_type, json_name, member_name);                                   \
    namespace JsonDeserialise {                                                                    \
        namespace @LIB_ID@ {                                                                       \
            struct object_type##_##member_name##_##EndoFunctor_                                    \
                : public EndoFunctor<decltype(((object_type*)nullptr)->member_name)> {             \
                using Base = EndoFunctor<decltype(((object_type*)nullptr)->member_name)>;          \
                template <typename... Args>                                                        \
                object_type##_##member_name##_##EndoFunctor_(Args&&... args)                       \
                    : Base(functor, args...) {}                                                    \
            };                                                                                     \
        }                                                                                          \
    }                                                                                              \
    template <>                                                                                    \
    struct JsonDeserialise::@LIB_ID@::Customised<decltype(((object_type*)nullptr)->member_name),   \
                                                 JsonDeserialise::object_type##_##member_name,     \
                                                 &object_type::member_name> {                      \
        using Type = object_type##_##member_name##_##EndoFunctor_;                                 \
    };
#define @lib@_object_member_with_endofunctor(object_type, member_name, functor)                    \
    JsonDeserialise::@LIB_ID@::ReinforcedInfo<                                                     \
        decltype(((object_type*)nullptr)->member_name),                                            \
        JsonDeserialise::object_type##_##member_name,                                              \
        sizeof(JsonDeserialise::object_type##_##member_name), &object_type::member_name, false,    \
        JsonDeserialise::@LIB_ID@::functor##_##EndoFunctor_>
#define @lib@_optional_object_member_with_endofunctor(object_type, member_name, functor)           \
    JsonDeserialise::@LIB_ID@::ReinforcedInfo<                                                     \
        decltype(((object_type*)nullptr)->member_name),                                            \
        JsonDeserialise::object_type##_##member_name,                                              \
        sizeof(JsonDeserialise::object_type##_##member_name), &object_type::member_name, true,     \
        JsonDeserialise::@LIB_ID@::functor##_##EndoFunctor_>

#ifdef DEFAULT_MODE
// Local
#define declare_top_deserialiser(data_name, var_name)                                              \
    @lib@_declare_top_deserialiser(data_name, var_name)
#define declare_deserialiser(json_name, data_name, var_name)                                       \
    @lib@_declare_deserialiser(json_name, data_name, var_name)
#define declare_top_serialiser(data_name, var_name)                                                \
    @lib@_declare_top_serialiser(data_name, var_name)
#define declare_serialiser(json_name, data_name, var_name)                                         \
    @lib@_declare_serialiser(json_name, data_name, var_name)
#define declare_extension_deserialiser(json_name, data_name, var_name, convertor, deconvertor)     \
    @lib@_declare_extension_deserialiser(json_name, data_name, var_name, convertor, deconvertor)
#define declare_one_direction_extension_deserialiser(json_name, data_name, var_name, convertor)    \
    @lib@_declare_one_direction_extension_deserialiser(json_name, data_name, var_name, convertor)
#define declare_one_direction_extension_serialiser(json_name, data_name, var_name, deconvertor)    \
    @lib@_declare_one_direction_extension_serialiser(json_name, data_name, var_name, deconvertor)
#define declare_top_map_of_object_object_deserialiser(data_name, key_name, var_name)               \
    @lib@_declare_top_map_of_object_object_deserialiser(data_name, key_name, var_name)
#define declare_map_of_object_deserialiser(json_name, data_name, key_name, var_name)               \
    @lib@_declare_map_of_object_deserialiser(json_name, data_name, key_name, var_name)
#define declare_top_pair_deserialiser(json_name1, json_name2, data_name, var_name)                 \
    @lib@_declare_top_pair_deserialiser(json_name1, json_name2, data_name, var_name)
#define declare_pair_deserialiser(json_name, json_name1, json_name2, data_name, var_name)          \
    @lib@_declare_pair_deserialiser(json_name, json_name1, json_name2, data_name, var_name)
#define declare_top_object_deserialiser(var_name, ...)                                             \
    @lib@_declare_top_object_deserialiser(var_name, __VA_ARGS__)
#define declare_top_array_of_object_deserialiser(data_name, var_name, object_type, ...)            \
    @lib@_declare_top_array_of_object_deserialiser(data_name, var_name, object_type, __VA_ARGS__)
#define declare_array_of_object_deserialiser(json_name, data_name, var_name, object_type, ...)     \
    @lib@_declare_array_of_object_deserialiser(json_name, data_name, var_name, object_type,        \
                                               __VA_ARGS__)
#define array_field(object_type, json_name, member_name)                                           \
    @lib@_array_field(object_type, json_name, member_name)

// Global
#define object_member(object_type, member_name) @lib@_object_member(object_type, member_name)
#define optional_object_member(object_type, member_name)                                           \
    @lib@_optional_object_member(object_type, member_name)
#define declare_object(object_type, ...) @lib@_declare_object(object_type, __VA_ARGS__)
#define declare_class_with_json_constructor_and_serialiser(object_type)                            \
    @lib@_declare_class_with_json_constructor_and_serialiser(object_type)
#define declare_object_with_base_class(object_type, base_type, ...)                                \
    @lib@_declare_object_with_base_class(object_type, base_type, __VA_ARGS__)
#define declare_enum_as(type_name, as) @lib@_declare_enum_as(type_name, as)
#define declare_global_extension(target_type, json_type, convertor, deconvertor)                   \
    @lib@_declare_global_extension(target_type, json_type, convertor, deconvertor)
#define declare_extension(name, target_type, json_type, convertor, deconvertor)                    \
    @lib@_declare_extension(name, target_type, json_type, convertor, deconvertor)
#define register_object_member_with_extension(object_type, json_name, member_name, json_type,      \
                                              convertor, deconvertor)                              \
    @lib@_register_object_member_with_extension(object_type, json_name, member_name, json_type,    \
                                                convertor, deconvertor)
#define object_member_with_extension(object_type, member_name, extension)                          \
    @lib@_object_member_with_extension(object_type, member_name, extension)
#define optional_object_member_with_extension(object_type, member_name, extension)                 \
    @lib@_optional_object_member_with_extension(object_type, member_name, extension)
#define declare_endofunctor(name, type, functor) @lib@_declare_endofunctor(name, type, functor)
#define register_object_member_with_endofunctor(object_type, json_name, member_name, functor)      \
    @lib@_register_object_member_with_endofunctor(object_type, json_name, member_name, functor)
#define object_member_with_endofunctor(object_type, member_name, functor)                          \
    @lib@_object_member_with_endofunctor(object_type, member_name, functor)
#define optional_object_member_with_endofunctor(object_type, member_name, functor)                 \
    @lib@_optional_object_member_with_endofunctor(object_type, member_name, functor)
#endif
